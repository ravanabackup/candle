<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bible Verse Quote Generator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --radius: 16px; --pad: 20px; }
    body{
      background:#121212;color:#fff;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
      display:flex;flex-direction:column;align-items:center;padding:20px;
    }
    h2{margin:0 0 10px}
    #container{
      position:relative;width:600px;max-width:95vw;margin-top:20px;border-radius:var(--radius);
      box-shadow:0 4px 20px rgba(0,0,0,.5);overflow:hidden;background:#000;
    }
    #bgImage{width:100%;display:block;transition:opacity .4s ease}
    #verseText{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      width:90%;text-align:center;color:#fff;font-weight:500;word-wrap:break-word;
      padding:var(--pad);border-radius:12px;
      backdrop-filter: blur(16px) brightness(.7);
      -webkit-backdrop-filter: blur(16px) brightness(.7);
      text-shadow:0 4px 8px rgba(0,0,0,.6);
      transition:opacity .2s ease;
    }
    /* Loader */
    #imageLoader{
      position:absolute;inset:0;display:none;place-items:center;background:rgba(0,0,0,.25);
    }
    .spinner{
      width:44px;height:44px;border-radius:50%;
      border:4px solid rgba(255,255,255,.25);border-top-color:#fff;animation:spin 1s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    textarea{
      width:600px;max-width:95vw;height:150px;margin-top:20px;padding:15px;border-radius:12px;
      border:1px solid #444;background:#1e1e1e;color:#fff;resize:vertical;font-size:16px;
    }
    textarea:focus{outline:none;border-color:#8ab4f8;box-shadow:0 0 0 2px #8ab4f8}

    #buttons{margin-top:10px;display:none;justify-content:center;flex-wrap:wrap}
    button{
      margin:10px;padding:12px 24px;border:0;border-radius:20px;background:#3c4043;color:#fff;cursor:pointer;
      font-size:16px;font-weight:500;letter-spacing:.3px;transition:background .2s,transform .15s,box-shadow .2s;
      box-shadow:0 2px 5px rgba(0,0,0,.4)
    }
    button:hover{background:#5f6368;transform:translateY(-2px)}
    button:disabled{opacity:.6;cursor:not-allowed;transform:none}

    .status{margin-top:10px;padding:10px;border-radius:8px;font-size:14px;text-align:center;display:none}
    .success{background:rgba(76,175,80,.18);color:#4CAF50;border:1px solid #4CAF50}
    .error{background:rgba(244,67,54,.18);color:#F44336;border:1px solid #F44336}
  </style>
</head>
<body>
  <h2>Bible Verse Quote Generator</h2>

  <textarea id="inputVerse" placeholder="Paste Bible verse here..."></textarea>
  <button id="btnGenerate" onclick="generateVerse()">Generate</button>

  <div id="container">
    <img id="bgImage" crossOrigin="anonymous" src="" alt="Background">
    <div id="imageLoader"><div class="spinner" aria-label="loading"></div></div>
    <div id="verseText"></div>
  </div>

  <div id="buttons">
    <button id="btnDownload" onclick="downloadImage()">Download</button>
    <button id="btnCopy" onclick="copyImage()">Copy</button>
    <button onclick="shareVerse()">Share</button>
    <button id="btnRefresh" onclick="refreshImage()">Refresh Image</button>
  </div>

  <div id="status" class="status"></div>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // --- helpers ---
    const $ = s => document.querySelector(s);
    const loader = $('#imageLoader');
    const container = $('#container');
    const bgImage = $('#bgImage');
    const verseBox = $('#verseText');
    const statusEl = $('#status');
    const buttons = $('#buttons');
    let busy = false;

    window.onload = refreshImage;

    function showStatus(msg, type='success'){
      statusEl.textContent = msg;
      statusEl.className = `status ${type}`;
      statusEl.style.display = 'block';
      clearTimeout(showStatus._t);
      showStatus._t = setTimeout(()=>statusEl.style.display='none', 2800);
    }

    function adjustFontSize(text){
      const len = text.length;
      if (len < 50) return 48;
      if (len < 120) return 36;
      if (len < 200) return 28;
      return 24;
    }

    function setBusy(on){
      busy = on;
      loader.style.display = on ? 'grid' : 'none';
      $('#btnDownload')?.toggleAttribute('disabled', on);
      $('#btnCopy')?.toggleAttribute('disabled', on);
      $('#btnRefresh')?.toggleAttribute('disabled', on);
      $('#btnGenerate')?.toggleAttribute('disabled', on);
    }

    function generateVerse(){
      const verse = $('#inputVerse').value.trim();
      if(!verse){ showStatus('Please enter a Bible verse.','error'); return; }
      // Preview text + size
      verseBox.textContent = verse;
      verseBox.style.fontSize = adjustFontSize(verse) + 'px';
      buttons.style.display = 'flex';
    }

    function refreshImage(){
      if (busy) return;
      setBusy(true);
      const t = Date.now();
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = `https://picsum.photos/1000?blur&t=${t}`;
      img.onload = () => { bgImage.src = img.src; setBusy(false); showStatus('Background image loaded!'); };
      img.onerror = () => { setBusy(false); showStatus('Failed to load image.','error'); };
      bgImage.style.opacity = '0';
      img.decode?.().finally(()=>{ bgImage.style.opacity = '1'; });
    }

    // Text wrapping (supports newlines)
    function wrapText(ctx, text, maxWidth, lineHeight){
      const paras = text.split(/\r\n|\r|\n/);
      const lines = [];
      for(const para of paras){
        if(para.trim()===''){ lines.push(''); continue; }
        const words = para.split(' ');
        let line = '';
        for(let i=0;i<words.length;i++){
          const test = line + words[i] + ' ';
          if(ctx.measureText(test).width > maxWidth && i>0){
            lines.push(line.trim());
            line = words[i] + ' ';
          }else{
            line = test;
          }
        }
        if(line.trim()) lines.push(line.trim());
      }
      return lines;
    }

    // Rounded-rect path
    function roundRectPath(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y,   x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x,   y+h, rr);
      ctx.arcTo(x,   y+h, x,   y,   rr);
      ctx.arcTo(x,   y,   x+w, y,   rr);
      ctx.closePath();
    }

    // Main render -> canvas that MATCHES preview
    function drawToCanvas(){
      return new Promise((resolve,reject)=>{
        const verse = $('#inputVerse').value.trim();
        if(!verse) return reject(new Error('No verse entered'));

        // Lock to exactly the image being shown
        const src = bgImage.currentSrc || bgImage.src;
        const tempImg = new Image();
        tempImg.crossOrigin = 'anonymous';
        tempImg.onload = async function(){
          const cvs = $('#canvas');
          const ctx = cvs.getContext('2d');
          const dpr = 1; // export at native image resolution
          cvs.width  = tempImg.naturalWidth * dpr;
          cvs.height = tempImg.naturalHeight * dpr;

          // draw background
          ctx.drawImage(tempImg, 0, 0, cvs.width, cvs.height);

          // Compute scaling from preview container -> canvas
          const scaleX = cvs.width / container.clientWidth;
          const scaleY = cvs.height / container.clientHeight;
          const scale = Math.min(scaleX, scaleY);

          // Box dimensions (same as preview: width 90% of container)
          const boxW = Math.round(container.clientWidth * 0.90 * scaleX);
          // font from preview sizing heuristic
          const previewFontPx = adjustFontSize(verse);
          const fontPx = previewFontPx * scale;
          const pad = parseFloat(getComputedStyle(verseBox).paddingLeft) * scaleX; // 20px * scale
          const lineHeight = fontPx * 1.2;

          ctx.font = `500 ${fontPx}px Roboto, Arial, sans-serif`;

          // Wrap text using the SAME width as the visual box minus padding
          const maxTextW = boxW - pad*2;
          const lines = wrapText(ctx, verse, maxTextW, lineHeight);
          const textH = lines.length * lineHeight;

          const boxH = Math.round(textH + pad*2);
          const boxX = Math.round((cvs.width - boxW)/2);
          const boxY = Math.round((cvs.height - boxH)/2);

          // Frosted background that matches CSS backdrop-filter:
          // 1) crop & blur the area from the original image into an offscreen canvas
          const frost = document.createElement('canvas');
          frost.width = boxW; frost.height = boxH;
          const fctx = frost.getContext('2d');
          // apply blur + darken similar to 'brightness(.7)'
          fctx.filter = `blur(${16*scale}px) brightness(.7)`;
          // draw the original image offset so only the box area shows
          fctx.drawImage(tempImg, -boxX, -boxY, cvs.width, cvs.height);

          // 2) draw that blurred patch into a rounded-rect clip
          ctx.save();
          roundRectPath(ctx, boxX, boxY, boxW, boxH, 12 * scale);
          ctx.clip();
          ctx.drawImage(frost, boxX, boxY);
          // subtle frosted tint
          ctx.fillStyle = 'rgba(255,255,255,.08)';
          ctx.fillRect(boxX, boxY, boxW, boxH);
          ctx.restore();

          // Optional soft border for glass
          ctx.save();
          roundRectPath(ctx, boxX, boxY, boxW, boxH, 12 * scale);
          ctx.strokeStyle = 'rgba(255,255,255,.18)';
          ctx.lineWidth = Math.max(1, 1 * scale);
          ctx.stroke();
          ctx.restore();

          // Draw text centered inside the box
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = 'rgba(0,0,0,.6)';
          ctx.shadowBlur = 8 * scale;
          const cx = boxX + boxW/2;
          let y = boxY + pad + lineHeight/2;
          for(const ln of lines){
            if (ln === '') { y += lineHeight; continue; }
            ctx.fillText(ln, cx, y);
            y += lineHeight;
          }

          resolve(cvs);
        };
        tempImg.onerror = () => reject(new Error('Failed to load background image'));
        tempImg.src = src;
      });
    }

    async function downloadImage(){
      try{
        setBusy(true);
        const canvas = await drawToCanvas();
        const link = document.createElement('a');
        link.download = 'bible-verse.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        showStatus('Image downloaded!');
      }catch(err){
        console.error(err); showStatus('Download failed','error');
      }finally{
        setBusy(false);
      }
    }

    async function copyImage(){
      try{
        setBusy(true);
        const canvas = await drawToCanvas();
        const dataUrl = canvas.toDataURL('image/png');
        const blob = await (await fetch(dataUrl)).blob(); // quick & reliable
        await navigator.clipboard.write([new ClipboardItem({'image/png': blob})]);
        showStatus('Image copied to clipboard!');
      }catch(err){
        console.error(err); showStatus('Copy failed','error');
      }finally{
        setBusy(false);
      }
    }

    function shareVerse(){
      const verse = $('#inputVerse').value.trim();
      if(!verse){ showStatus('Please enter a verse first','error'); return; }
      if(navigator.share){
        navigator.share({ title:'Bible Verse', text:verse, url:location.href })
          .then(()=>showStatus('Shared!'))
          .catch(()=>navigator.clipboard.writeText(verse).then(()=>showStatus('Verse copied!')));
      }else{
        navigator.clipboard.writeText(verse).then(()=>showStatus('Verse copied!'));
      }
    }
  </script>
</body>
</html>
