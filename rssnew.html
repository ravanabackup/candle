<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>YouTube RSS Feed Reader</title>
    <style>
        /* Material You Expressive Palette + UI */
        :root{
            --md-sys-color-primary-light: #6750A4;
            --md-sys-color-on-primary-light: #FFFFFF;
            --md-sys-color-primary-container-light: #EADDFF;
            --md-sys-color-on-primary-container-light: #21005D;
            --md-sys-color-secondary-light: #625B71;
            --md-sys-color-on-secondary-light: #FFFFFF;
            --md-sys-color-tertiary-light: #7D5260;
            --md-sys-color-on-tertiary-light: #FFFFFF;
            --md-sys-color-surface-light: #FFFBFE;
            --md-sys-color-on-surface-light: #1C1B1F;
            --md-sys-color-error-light: #B3261E;
            --md-sys-color-error-container-light: #F9DEDC;

            --md-sys-color-primary-dark: #D0BCFF;
            --md-sys-color-on-primary-dark: #381E72;
            --md-sys-color-primary-container-dark: #4F378B;
            --md-sys-color-on-primary-container-dark: #EADDFF;
            --md-sys-color-secondary-dark: #CCC2DC;
            --md-sys-color-on-secondary-dark: #332D41;
            --md-sys-color-tertiary-dark: #EFB8C8;
            --md-sys-color-on-tertiary-dark: #492532;
            --md-sys-color-surface-dark: #1C1B1F;
            --md-sys-color-on-surface-dark: #E6E1E5;
            --md-sys-color-error-dark: #F2B8B5;
            --md-sys-color-error-container-dark: #8C1D18;
        }

        body.light-theme{
            --background-color: var(--md-sys-color-surface-light);
            --surface-color: var(--md-sys-color-surface-light);
            --surface-variant-color: var(--md-sys-color-primary-container-light);
            --primary-color: var(--md-sys-color-primary-light);
            --secondary-color: var(--md-sys-color-secondary-light);
            --text-color: var(--md-sys-color-on-surface-light);
            --text-secondary-color: var(--md-sys-color-on-primary-container-light);
            --error-color: var(--md-sys-color-error-light);
            --no-stats-bg: #FFEBEE;
            --no-stats-border: #F8BBD0;
        }
        body.dark-theme{
            --background-color: var(--md-sys-color-surface-dark);
            --surface-color: var(--md-sys-color-surface-dark);
            --surface-variant-color: var(--md-sys-color-primary-container-dark);
            --primary-color: var(--md-sys-color-primary-dark);
            --secondary-color: var(--md-sys-color-secondary-dark);
            --text-color: var(--md-sys-color-on-surface-dark);
            --text-secondary-color: var(--md-sys-color-on-primary-container-dark);
            --error-color: var(--md-sys-color-error-dark);
            --no-stats-bg: #2C2020;
            --no-stats-border: #8C1D18;
        }

        *{box-sizing:border-box;margin:0;padding:0}
        body{
            min-height:100vh;
            padding:20px;
            font-family: 'Google Sans','Segoe UI',Tahoma, Geneva, Verdana, sans-serif;
            background:var(--background-color);
            color:var(--text-color);
            transition: background-color .3s, color .3s;
        }

        .container{max-width:1200px;margin:0 auto}
        .header{
            text-align:center;margin-bottom:20px;padding:18px;border-radius:16px;
            background:linear-gradient(90deg, color-mix(in srgb, var(--surface-color) 92%, black 2%), var(--surface-variant-color));
            box-shadow:0 8px 30px rgba(0,0,0,0.12);
        }
        .header h1{font-size:2rem;color:var(--primary-color);margin-bottom:8px}
        .status{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:10px;align-items:center}
        .status-item{display:flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;background:rgba(255,255,255,0.03);color:var(--text-secondary-color);font-weight:600}
        .status-indicator{width:12px;height:12px;border-radius:50%;background:#bdbdbd;display:inline-block}
        .status-indicator.loading{background:#ff9800;animation:pulse 2s infinite}
        .status-indicator.connected{background:#4caf50}
        .status-indicator.error{background:#f44336}
        @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}

        .filter-controls{display:flex;gap:8px;justify-content:center;margin-top:14px}
        .filter-button{padding:8px 14px;border-radius:999px;border:2px solid var(--primary-color);background:transparent;color:var(--primary-color);cursor:pointer;font-weight:600}
        .filter-button.active{background:var(--primary-color);color:var(--md-sys-color-on-primary-dark);box-shadow:0 8px 20px rgba(0,0,0,0.15);transform:translateY(-2px)}

        .feed-container{background:var(--surface-color);padding:18px;border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,0.12);margin-top:18px}
        #debugLog{margin-top:18px;padding:12px;border-radius:12px;background:var(--surface-variant-color);font-family:monospace;color:var(--text-color)}
        #debugLog h4{color:var(--primary-color);margin-bottom:8px}
        #debugLog pre{max-height:220px;overflow:auto;background:transparent;color:var(--text-secondary-color)}

        .feed-list{display:flex;flex-direction:column;gap:12px}
        .feed-item{
            display:flex;gap:14px;align-items:flex-start;padding:14px;border-radius:12px;
            background:linear-gradient(180deg, color-mix(in srgb,var(--surface-variant-color) 95%, transparent), var(--surface-color));
            border-left:6px solid var(--primary-color);
            transition:transform .16s ease, box-shadow .16s ease;
            position:relative;
        }
        .feed-item:hover{transform:translateY(-4px);box-shadow:0 18px 40px rgba(0,0,0,0.12)}
        .feed-item.no-stats-post{background:var(--no-stats-bg);border-left-color:var(--no-stats-border)}
        .feed-thumbnail-container{width:200px;height:112px;flex-shrink:0;position:relative;cursor:pointer;border-radius:10px;overflow:hidden}
        .feed-thumbnail{width:100%;height:100%;object-fit:cover;display:block}
        .play-icon{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
        .play-icon::after{content:'';border-style:solid;border-width:16px 0 16px 26px;border-color:transparent transparent transparent rgba(255,255,255,0.9)}
        .iframe-container{width:200px;height:112px;border-radius:10px;overflow:hidden;flex-shrink:0}
        .feed-content{flex:1;min-width:0}
        .feed-title{font-weight:700;font-size:1.1rem;margin-bottom:6px;color:var(--text-color)}
        .feed-date{color:var(--text-secondary-color);font-weight:600;margin-bottom:8px;display:flex;gap:12px;flex-wrap:wrap}
        .feed-description{color:var(--text-secondary-color);line-height:1.45;margin-bottom:12px}
        .actions{display:flex;gap:8px;flex-wrap:wrap}
        .action-button{padding:8px 12px;border-radius:999px;border:none;cursor:pointer;background:var(--primary-color);color:var(--md-sys-color-on-primary-dark);font-weight:600}
        .action-button.copy{background:var(--secondary-color);color:var(--md-sys-color-on-secondary-dark)}
        .action-button.advanced{background:transparent;border:2px solid var(--primary-color);color:var(--primary-color)}

        .loading{text-align:center;padding:30px;color:var(--primary-color)}
        .spinner{width:36px;height:36px;border-radius:50%;border:4px solid color-mix(in srgb,var(--primary-color) 30%, transparent);border-top-color:var(--primary-color);animation:spin 1s linear infinite;margin:0 auto 10px}
        @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}

        .theme-switch{position:fixed;right:20px;bottom:20px;width:50px;height:50px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:var(--primary-color);color:var(--md-sys-color-on-primary-dark);cursor:pointer;box-shadow:0 8px 30px rgba(0,0,0,0.18)}
        .modal{display:none;position:fixed;inset:0;z-index:200;align-items:center;justify-content:center;background:rgba(0,0,0,0.4)}
        .modal-content{background:var(--surface-color);padding:22px;border-radius:12px;min-width:300px;max-width:520px;position:relative}
        .close-button{position:absolute;right:14px;top:10px;font-size:22px;cursor:pointer;color:var(--text-secondary-color)}

        /* Translation progress */
        .progress-track{width:100%;height:10px;background:rgba(0,0,0,0.06);border-radius:999px;overflow:hidden}
        .progress-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--primary-color), color-mix(in srgb,var(--primary-color) 60%, black 10%));transition:width .2s ease}

        @media(max-width:768px){
            .feed-item{flex-direction:column}
            .feed-thumbnail-container,.iframe-container{width:100%;height:auto;min-height:180px}
        }
    </style>
</head>
<body class="dark-theme">
    <div class="theme-switch" id="themeSwitch"><span id="themeIcon">‚òÄÔ∏è</span></div>

    <div class="container">
        <div class="header">
            <h1>üé• YouTube RSS Feed Reader</h1>
            <div class="status">
                <div class="status-item"><span class="status-indicator" id="statusIndicator"></span> <span>Status: <b id="status">Loading...</b></span></div>
                <div class="status-item">üìÖ Last Update: <b id="lastUpdate">Never</b></div>
                <div class="status-item">üìä Total Posts: <b id="totalPosts">0</b></div>
                <div class="status-item">üîî New Posts: <b id="newPosts">0</b></div>
                <button id="advancedSettingsButton" class="action-button advanced">‚öôÔ∏è Advanced</button>
            </div>

            <div class="filter-controls" style="margin-top:12px">
                <button class="filter-button active" data-filter="all">All</button>
                <button class="filter-button" data-filter="released">Released</button>
                <button class="filter-button" data-filter="unreleased">Unreleased</button>
            </div>
        </div>

        <div class="feed-container">
            <div id="feedContent">
                <div class="loading"><div class="spinner"></div>Loading RSS feed...</div>
            </div>

            <div id="debugLog">
                <h4>Debug Log</h4>
                <pre id="logContent"></pre>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeModalButton">&times;</span>
            <h3>Advanced Settings</h3>

            <div style="display:flex;justify-content:space-between;align-items:center;padding:10px 0;border-bottom:1px solid rgba(0,0,0,0.06)">
                <div>Debug Mode</div>
                <label style="display:inline-flex;align-items:center;gap:8px">
                    <input type="checkbox" id="debugSwitch" checked> <span style="font-weight:600;color:var(--text-secondary-color)">Enabled</span>
                </label>
            </div>

            <div style="display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid rgba(0,0,0,0.06)">
                <div>Translation (ml ‚Üí en)</div>
                <label style="display:inline-flex;align-items:center;gap:8px">
                    <input type="checkbox" id="translationSwitch"> <span style="font-weight:600;color:var(--text-secondary-color)">Enabled</span>
                </label>
            </div>

            <div id="translationProgress" style="display:none;margin-top:12px">
                <div style="font-weight:600;margin-bottom:8px">Translating titles... <span id="translationProgressText">0/0</span></div>
                <div class="progress-track"><div id="translationProgressFill" class="progress-fill"></div></div>
            </div>
        </div>
    </div>

    <div id="messageModal" class="modal">
        <div class="modal-content">
            <div id="messageText"></div>
            <div style="text-align:right;margin-top:12px"><button id="closeMessageModalButton" class="action-button">OK</button></div>
        </div>
    </div>

    <audio id="notificationSound" src="https://raw.githubusercontent.com/ravanabackup/candle/refs/heads/main/ding.mp3"></audio>

    <script>
    /**
     * Updated RSSFeedReader:
     * - Fix: preserve liveStreamingDetails on subsequent fetches (avoid overwriting with null)
     * - Add: translation progress bar in settings modal, cancellable by toggling off
     * - Keep incremental DOM updates (no full-page refresh)
     */

    class RSSFeedReader {
        constructor(){
            // CONFIG
            this.feedUrl = 'https://cors.kawiesh.top/https://www.youtube.com/feeds/videos.xml?channel_id=UCbg8V1kty3s1kcCch2VHwEw';
            this.YT_API_KEY = 'AIzaSyAzDe7gqM5P_cGwxreEVtzAbrk-5BubrcM'; // your key
            this.pollIntervalMs = 60000; // periodic feed poll
            this.forceStatusIntervalMs = 5 * 60 * 1000; // 5 minutes when no feed
            // state
            this.knownItemsKey = 'rss-known-items';
            this.knownItems = this.loadKnownItems();
            this.feedMap = new Map(); // id -> item object
            this.newItemsCount = 0;
            this.originalTitle = document.title;
            this.currentFilter = 'all';
            this.isDebugging = true;
            this.isTranslationEnabled = false;
            this.translationInProgress = false;
            // DOM
            this.feedContent = document.getElementById('feedContent');
            this.logContentElement = document.getElementById('logContent');
            this.debugLogElement = document.getElementById('debugLog');
            this.debugSwitch = document.getElementById('debugSwitch');
            this.translationSwitch = document.getElementById('translationSwitch');
            this.translationProgress = document.getElementById('translationProgress');
            this.translationProgressFill = document.getElementById('translationProgressFill');
            this.translationProgressText = document.getElementById('translationProgressText');
            this.notificationSound = document.getElementById('notificationSound');
            // timers
            this.updateInterval = null;
            this.forceStatusTimer = null;

            this.init();
        }

        init(){
            this.setupThemeSwitch();
            this.setupModal();
            this.setupFilterControls();
            this.setupDebugToggle();
            this.fetchFeed(); // initial fetch
            this.updateInterval = setInterval(()=>this.fetchFeed(), this.pollIntervalMs);
            // keep the debug visible by default
            this.debugLogElement.style.display = this.isDebugging ? 'block' : 'none';
        }

        /* ---------- localStorage helpers ---------- */
        loadKnownItems(){
            const stored = localStorage.getItem(this.knownItemsKey);
            try{
                return stored ? new Set(JSON.parse(stored)) : new Set();
            }catch(e){
                console.error('Failed parse known items', e);
                return new Set();
            }
        }
        saveKnownItems(){
            localStorage.setItem(this.knownItemsKey, JSON.stringify(Array.from(this.knownItems)));
        }

        /* ---------- logging ---------- */
        logMessage(msg){
            if(!this.isDebugging) return;
            const now = new Date().toLocaleTimeString('en-GB');
            this.logContentElement.textContent += `[${now}] ${msg}\n`;
            this.logContentElement.scrollTop = this.logContentElement.scrollHeight;
        }

        /* ---------- feed fetch & processing ---------- */
        async fetchFeed(){
            this.logMessage('Starting feed fetch...');
            this.updateStatus('Fetching...');
            try{
                const r = await fetch(this.feedUrl);
                if(!r.ok) throw new Error('HTTP ' + r.status);
                const xmlText = await r.text();
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                this.logMessage('Feed XML parsed');
                const { items, idsInFeed } = this.parseFeedXml(xmlDoc);

                // Determine diffs: new / removed / possibly-updated
                const newIds = idsInFeed.filter(id => !this.feedMap.has(id));
                const removedIds = Array.from(this.feedMap.keys()).filter(id => !idsInFeed.includes(id));
                const possiblyUpdatedIds = idsInFeed.filter(id => this.feedMap.has(id)); // could check updated timestamp

                this.logMessage(`Found ${items.length} items. New: ${newIds.length}, Removed: ${removedIds.length}`);

                // Remove DOM for removed items
                removedIds.forEach(id => {
                    this.feedMap.delete(id);
                    this.removeItemFromDOM(id);
                    // optional: remove known items as it's no longer in feed
                    // keep it removed so reappearing posts are treated fresh
                    this.knownItems.delete(id);
                });
                this.saveKnownItems();

                // Add or update items in map (but do not re-render entire list)
                const newItemsObjects = [];
                for(const it of items){
                    const prev = this.feedMap.get(it.id);
                    if(!prev){
                        // brand new item
                        this.feedMap.set(it.id, it);
                        newItemsObjects.push(it);
                    } else {
                        // MERGE carefully ‚Äî preserve previously fetched liveStreamingDetails & translations & good community stats
                        const merged = Object.assign({}, prev, it);

                        // Preserve liveStreamingDetails if prev had it and parsed item doesn't
                        merged.liveStreamingDetails = (it.liveStreamingDetails !== null && it.liveStreamingDetails !== undefined) ? it.liveStreamingDetails : (prev.liveStreamingDetails || null);

                        // Preserve translatedTitle if previously translated
                        merged.translatedTitle = prev.translatedTitle || it.translatedTitle || null;

                        // Preserve community stats if parsed feed has empty/zero stats but previous had data
                        const itViews = it.community && it.community.views ? parseInt(it.community.views) : 0;
                        const prevViews = prev.community && prev.community.views ? parseInt(prev.community.views) : 0;
                        if(!it.community || itViews === 0){
                            merged.community = prev.community || it.community;
                        } else {
                            merged.community = it.community;
                        }

                        this.feedMap.set(it.id, merged);

                        // Re-render only if meaningful fields changed
                        const changed = (prev.title !== merged.title) || (prev.summary !== merged.summary) || (JSON.stringify(prev.liveStreamingDetails) !== JSON.stringify(merged.liveStreamingDetails)) || (prev.translatedTitle !== merged.translatedTitle);
                        if(changed) this.updateItemInDOM(merged);
                    }
                }

                // Insert newly found items into DOM and process them
                const newVideoIds = [];
                if(newItemsObjects.length > 0){
                    this.logMessage(`${newItemsObjects.length} new items detected`);
                    // mark as known right away to suppress duplicate notif across rapid fetches
                    newItemsObjects.forEach(it => { this.knownItems.add(it.id); });
                    this.saveKnownItems();

                    // Insert items into DOM (prepend newest)
                    newItemsObjects.forEach(it => this.insertItemToDOM(it, true));

                    // Collect new video ids to query YouTube API
                    newItemsObjects.forEach(it => { if(it.videoId) newVideoIds.push(it.videoId); });

                    // Call YouTube API only for new video IDs
                    if(newVideoIds.length > 0){
                        await this.getLiveStatusForVideoIds(newVideoIds);
                        // After merging from YT, update DOM of those items
                        for(const vid of newVideoIds){
                            for(const item of this.feedMap.values()){
                                if(item.videoId === vid) this.updateItemInDOM(item);
                            }
                        }
                    }

                    // play sound & notify
                    this.playNotificationSound();
                } else {
                    this.logMessage('No new items this fetch.');
                }

                // If feed is empty, force YT status updates every 5 mins
                if(this.feedMap.size === 0){
                    this.logMessage('Feed is empty ‚Äî scheduling forced YouTube status checks every 5 minutes.');
                    this.scheduleForceStatusChecks();
                } else {
                    this.clearForceStatusChecks();
                }

                // Update UI
                this.updateTotalPosts();
                this.updateStatus('Connected');
                this.updateLastUpdateTime();
                this.updateTitle();

                // Apply active filter (ensure new/updated items obey selected filter)
                this.applyFilter();
            } catch(err){
                console.error('fetchFeed error',err);
                this.logMessage('Error fetching feed: ' + err.message);
                this.showError('Failed to load RSS feed: ' + err.message);
                this.updateStatus('Error');
            }
        }

        parseFeedXml(xmlDoc){
            const entries = Array.from(xmlDoc.querySelectorAll('entry'));
            const items = [];
            const idsInFeed = [];
            for(const entry of entries){
                const id = entry.querySelector('id')?.textContent || '';
                if(!id) continue;
                if(idsInFeed.includes(id)) continue;
                idsInFeed.push(id);

                const originalTitle = entry.querySelector('title')?.textContent || 'No title';
                const link = entry.querySelector('link')?.getAttribute('href') || '#';
                const published = entry.querySelector('published')?.textContent || '';
                const updated = entry.querySelector('updated')?.textContent || '';
                const mediaGroup = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'group')[0];
                let summary = entry.querySelector('summary')?.textContent || 'No description available';
                if(mediaGroup){
                    const desc = mediaGroup.getElementsByTagNameNS('http://search.yahoo.com/mrss/','description')[0];
                    if(desc && desc.textContent.trim() !== '') summary = desc.textContent;
                }
                const community = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/','community')[0];
                const starRating = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/','starRating')[0]?.getAttribute('average') || '0.00';
                const ratingCount = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/','starRating')[0]?.getAttribute('count') || '0';
                const views = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/','statistics')[0]?.getAttribute('views') || '0';

                const videoId = this.extractVideoId(link);
                const thumbnail = videoId ? `https://cors.kawiesh.top/https://i2.ytimg.com/vi/${videoId}/hqdefault.jpg` : null;

                const isNew = !this.knownItems.has(id);
                const hasStats = parseInt(views) > 0;

                const item = {
                    id,
                    title: originalTitle,
                    originalTitle: originalTitle,
                    translatedTitle: null,
                    link,
                    published: this.parseDateTime(published),
                    updated: this.parseDateTime(updated),
                    summary: this.cleanSummary(summary),
                    thumbnail,
                    community: { starRating, ratingCount, views },
                    isNew,
                    hasStats,
                    videoId,
                    liveStreamingDetails: null
                };

                items.push(item);
            }

            // Sort newest first
            items.sort((a,b)=> new Date(b.published.full) - new Date(a.published.full));
            return { items, idsInFeed };
        }

        /* ---------- YouTube API ---------- */
        async getLiveStatusForVideoIds(videoIdList){
            if(!this.YT_API_KEY || this.YT_API_KEY === 'YOUR_YOUTUBE_API_KEY_HERE') {
                this.logMessage('YouTube API key not configured ‚Äî skipping live status checks.');
                return;
            }
            if(!videoIdList || videoIdList.length===0) {
                this.logMessage('No video IDs provided to YouTube API call.');
                return;
            }
            // split into chunks to avoid very long URLs
            const chunks = [];
            for(let i=0;i<videoIdList.length;i+=50) chunks.push(videoIdList.slice(i,i+50));
            try{
                for(const chunk of chunks){
                    const parts = 'id,liveStreamingDetails';
                    const url = `https://www.googleapis.com/youtube/v3/videos?part=${parts}&id=${chunk.join(',')}&key=${this.YT_API_KEY}`;
                    this.logMessage(`Calling YouTube API for ${chunk.length} videos...`);
                    const res = await fetch(url);
                    if(!res.ok) { this.logMessage('YouTube API responded with status ' + res.status); continue; }
                    const data = await res.json();
                    if(!data.items) continue;
                    // Map response into feed items
                    for(const obj of data.items){
                        const vid = obj.id;
                        const liveDetails = obj.liveStreamingDetails || null;
                        // find corresponding feed item by videoId
                        for(const [id,item] of this.feedMap.entries()){
                            if(item.videoId === vid){
                                item.liveStreamingDetails = liveDetails;
                                this.feedMap.set(id, item);
                                this.logMessage(`Merged live details for video ${vid}`);
                                // update DOM for this item (if present)
                                this.updateItemInDOM(item);
                            }
                        }
                    }
                }
            }catch(err){
                console.error('getLiveStatusForVideoIds err',err);
                this.logMessage('Error fetching live status: ' + err.message);
            }
        }

        scheduleForceStatusChecks(){
            if(this.forceStatusTimer) return;
            this.forceStatusTimer = setInterval(async () => {
                this.logMessage('Forced status check (feed empty). Attempting to call YouTube API for any known video IDs.');
                const knownVideoIds = Array.from(this.feedMap.values()).map(i => i.videoId).filter(Boolean);
                if(knownVideoIds.length>0){
                    await this.getLiveStatusForVideoIds(knownVideoIds);
                } else {
                    this.logMessage('No known video IDs to check.');
                }
            }, this.forceStatusIntervalMs);
        }
        clearForceStatusChecks(){
            if(this.forceStatusTimer){
                clearInterval(this.forceStatusTimer);
                this.forceStatusTimer = null;
                this.logMessage('Cleared forced status checks.');
            }
        }

        /* ---------- DOM insert/update/remove helpers ---------- */

        makeItemHtml(item){
            const displayTitle = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
            let dateDisplay = '';
            let communityHtml = '';
            let postClass = item.isNew ? ' new' : '';
            let copyDate = item.published?.date || '';
            let copyTime = item.published?.time || '';

            if(item.liveStreamingDetails){
                const l = item.liveStreamingDetails;
                if(l.actualStartTime && !l.actualEndTime){
                    dateDisplay = 'üî¥ Live Now';
                    communityHtml = `<div class="date-item">üìà <b>Community Stats:</b> Live stream in progress!</div>`;
                    postClass += ' no-stats-post';
                } else if(l.scheduledStartTime && !l.actualStartTime){
                    const sched = this.parseDateTime(l.scheduledStartTime);
                    dateDisplay = `‚è∞ Scheduled: ${sched.date} ${sched.time}`;
                    communityHtml = `<div class="date-item">üìà Community Stats: Not available (Scheduled)</div>`;
                    copyDate = sched.date; copyTime = sched.time;
                    postClass += ' no-stats-post';
                } else if(l.actualStartTime){
                    const started = this.parseDateTime(l.actualStartTime);
                    dateDisplay = `üìÖ Published: ${started.date} ${started.time}`;
                    copyDate = started.date; copyTime = started.time;
                    if(item.updated) dateDisplay += ` | üîÑ Updated: ${item.updated.date} ${item.updated.time}`;
                    const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views);
                    const starRating = '‚≠ê'.repeat(Math.round(parseFloat(item.community.starRating||0)));
                    communityHtml = `<div class="date-item">üìà <b>Community Stats:</b><br>${starRating} (${item.community.starRating} avg from ${item.community.ratingCount})<br>üëÄ Views: ${formattedViews}</div>`;
                }
            } else {
                dateDisplay = `üìÖ Published: ${item.published?.date || 'Unknown'} ${item.published?.time || ''}`;
                if(item.updated) dateDisplay += ` | üîÑ Updated: ${item.updated.date} ${item.updated.time}`;
                if(item.hasStats){
                    const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views);
                    const starRating = '‚≠ê'.repeat(Math.round(parseFloat(item.community.starRating||0)));
                    communityHtml = `<div class="date-item">üìà <b>Community Stats:</b><br>${starRating} (${item.community.starRating} avg from ${item.community.ratingCount})<br>üëÄ Views: ${formattedViews}</div>`;
                } else {
                    communityHtml = `<div class="date-item">üìà <b>Community Stats:</b> Not yet available</div>`;
                    postClass += ' no-stats-post';
                }
            }

            const descriptionHtml = item.hasStats ? `<div class="feed-description">${this.escapeHtml(item.summary)}</div>` : '';

            const thumbnailHtml = item.thumbnail ? `
                <div class="feed-thumbnail-container" data-video-id="${item.videoId}">
                    <img src="${item.thumbnail}" alt="${this.escapeHtml(displayTitle)}" class="feed-thumbnail" onerror="this.style.display='none'"/>
                    <div class="play-icon"></div>
                </div>
            ` : '';

            return `
                <div class="feed-item${postClass}" data-id="${this.escapeHtml(item.id)}" data-video-id="${this.escapeHtml(item.videoId || '')}" data-video-link="${this.escapeHtml(item.link)}">
                    <div class="feed-item-content" style="display:flex;gap:14px;align-items:flex-start;width:100%">
                        ${thumbnailHtml}
                        <div class="feed-content">
                            <div class="feed-title">${this.escapeHtml(displayTitle)}</div>
                            <div class="feed-date"><div class="date-item">${dateDisplay}</div></div>
                            ${descriptionHtml}
                            ${communityHtml}
                            <div class="actions">
                                <a href="${this.escapeHtml(item.link)}" class="action-button" target="_blank" onclick="event.stopPropagation()">üé¨ Watch Video</a>
                                <button class="action-button copy" onclick="event.stopPropagation(); window.app.copyToClipboard('${this.jsEscape(item.originalTitle)}','${this.jsEscape(copyDate)}','${this.jsEscape(copyTime)}','${this.jsEscape(item.link)}')">üìã Copy Info</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        insertItemToDOM(item, prepend=false){
            const div = document.createElement('div');
            div.innerHTML = this.makeItemHtml(item);
            const node = div.firstElementChild;
            if(!node) return;
            const feedList = this.getOrCreateFeedList();
            if(prepend) feedList.insertBefore(node, feedList.firstChild);
            else feedList.appendChild(node);
            this.attachThumbnailHandler(node);
            // apply filter state for this new node
            this.applyFilterToNode(node);
        }

        updateItemInDOM(item){
            const selector = `.feed-item[data-id="${this.escapeCssSelector(item.id)}"]`;
            const existing = document.querySelector(selector);
            if(!existing){
                // Not present; simply insert at top
                this.insertItemToDOM(item, true);
                return;
            }
            // Replace element with new node (keeps DOM updated without clearing whole list)
            const wrapper = document.createElement('div');
            wrapper.innerHTML = this.makeItemHtml(item);
            const newNode = wrapper.firstElementChild;
            existing.replaceWith(newNode);
            this.attachThumbnailHandler(newNode);
            this.applyFilterToNode(newNode);
        }

        removeItemFromDOM(id){
            const node = document.querySelector(`.feed-item[data-id="${this.escapeCssSelector(id)}"]`);
            if(node) node.remove();
        }

        getOrCreateFeedList(){
            let list = document.querySelector('.feed-list');
            if(!list){
                this.feedContent.innerHTML = '';
                list = document.createElement('div'); list.className = 'feed-list';
                this.feedContent.appendChild(list);
            }
            return list;
        }

        attachThumbnailHandler(root){
            const thumb = root.querySelector('.feed-thumbnail-container');
            if(!thumb) return;
            thumb.addEventListener('click', (ev)=>{
                const videoId = thumb.dataset.videoId;
                if(videoId){
                    const iframe = this.createIframeWrapper(videoId);
                    thumb.replaceWith(iframe);
                }
                ev.stopPropagation();
            });
        }

        createIframeWrapper(videoId){
            const wrapper = document.createElement('div');
            wrapper.className = 'iframe-container';
            const iframe = document.createElement('iframe');
            iframe.width = "200";
            iframe.height = "112";
            iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
            iframe.frameBorder = "0";
            iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
            iframe.allowFullscreen = true;
            wrapper.appendChild(iframe);
            return wrapper;
        }

        /* ---------- UI helpers ---------- */
        playNotificationSound(){
            if(this.notificationSound){
                try{
                    this.notificationSound.currentTime = 0;
                    this.notificationSound.play().catch(e=>this.logMessage('Sound play prevented: ' + e.message));
                }catch(e){ this.logMessage('Sound play err: ' + e.message); }
            }
        }

        updateTitle(){
            const newCount = Array.from(this.feedMap.values()).filter(i=>i.isNew).length;
            this.newItemsCount = newCount;
            if(newCount>0) document.title = `(${newCount}) New Posts - ${this.originalTitle}`;
            else document.title = this.originalTitle;
        }

        updateStatus(status){
            document.getElementById('status').textContent = status;
            const indicator = document.getElementById('statusIndicator');
            indicator.className = 'status-indicator';
            if(status === 'Connected') indicator.classList.add('connected');
            else if(status === 'Error') indicator.classList.add('error');
            else indicator.classList.add('loading');
        }

        updateLastUpdateTime(){
            const now = new Date();
            const opts = { day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit' };
            document.getElementById('lastUpdate').textContent = now.toLocaleString('en-GB', opts);
        }

        updateTotalPosts(){
            document.getElementById('totalPosts').textContent = this.feedMap.size;
            document.getElementById('newPosts').textContent = this.newItemsCount;
            // also update filter labels counts
            const allCount = this.feedMap.size;
            const releasedCount = Array.from(this.feedMap.values()).filter(item => !item.liveStreamingDetails || (item.liveStreamingDetails && item.liveStreamingDetails.actualEndTime)).length;
            const unreleasedCount = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && !item.liveStreamingDetails.actualEndTime).length;
            document.querySelector('[data-filter="all"]').textContent = `All (${allCount})`;
            document.querySelector('[data-filter="released"]').textContent = `Released (${releasedCount})`;
            document.querySelector('[data-filter="unreleased"]').textContent = `Unreleased (${unreleasedCount})`;
        }

        showError(message){
            this.feedContent.innerHTML = `<div class="error" style="padding:20px;border-radius:10px;background:var(--md-sys-color-error-container-light);color:var(--error-color)"><h3>‚ö†Ô∏è Error</h3><p>${this.escapeHtml(message)}</p></div>`;
        }

        showMessageBox(msg){
            const modal = document.getElementById('messageModal');
            document.getElementById('messageText').textContent = msg;
            modal.style.display = 'flex';
        }

        /* ---------- utilities ---------- */
        extractVideoId(url){
            const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }
        parseDateTime(dateString){
            if(!dateString) return {date:'',time:'',full:null};
            const d = new Date(dateString);
            const options = { year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:true, timeZone:'Asia/Kolkata' };
            const formatter = new Intl.DateTimeFormat('en-GB', options);
            const parts = formatter.formatToParts(d);
            const dateFormatted = `${parts.find(p=>p.type==='day').value}-${parts.find(p=>p.type==='month').value}-${parts.find(p=>p.type==='year').value}`;
            const timeFormatted = `${parts.find(p=>p.type==='hour').value}:${parts.find(p=>p.type==='minute').value}:${parts.find(p=>p.type==='second').value} ${parts.find(p=>p.type==='dayPeriod').value}`;
            return { date: dateFormatted, time: timeFormatted, full: d.toString() };
        }
        cleanSummary(summary){
            if(!summary) return '';
            const clean = summary.replace(/<[^>]*>/g, '').trim();
            return clean.length>200 ? clean.substring(0,200) + '...' : clean;
        }
        escapeHtml(text){
            const d = document.createElement('div'); d.textContent = text; return d.innerHTML;
        }
        jsEscape(s){
            if(!s) return '';
            return s.replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\n/g,'\\n').replace(/\r/g,'');
        }
        escapeCssSelector(s){
            // use CSS.escape when available, fallback conservative replace
            if(window.CSS && CSS.escape) return CSS.escape(s);
            return s.replace(/(["\\])/g, '\\$1');
        }

        copyToClipboard(title,date,time,url){
            const textToCopy = `Title: ${title}\nDate: ${date} ${time}\nURL: ${url}`;
            const ta = document.createElement('textarea');
            ta.value = textToCopy;
            document.body.appendChild(ta);
            ta.select();
            try{
                document.execCommand('copy');
                this.showMessageBox('Video info copied to clipboard!');
            }catch(e){
                this.logMessage('Copy failed: ' + e.message);
            }
            ta.remove();
        }

        /* ---------- UI wiring ---------- */
        setupModal(){
            const modal = document.getElementById('settingsModal');
            const advBtn = document.getElementById('advancedSettingsButton');
            const closeBtn = document.getElementById('closeModalButton');
            advBtn.addEventListener('click', ()=> modal.style.display = 'flex');
            closeBtn.addEventListener('click', ()=> modal.style.display = 'none');
            window.addEventListener('click', (ev)=>{ if(ev.target === modal) modal.style.display = 'none'; });
            document.getElementById('closeMessageModalButton').addEventListener('click', ()=> document.getElementById('messageModal').style.display = 'none');

            this.translationSwitch.addEventListener('change', async ()=>{
                this.isTranslationEnabled = this.translationSwitch.checked;
                this.logMessage('Translation toggled ' + (this.isTranslationEnabled ? 'on' : 'off'));

                // If enabling: translate any items that lack translatedTitle, show progress UI
                if(this.isTranslationEnabled){
                    const itemsToTranslate = Array.from(this.feedMap.values()).filter(item => !item.translatedTitle);
                    if(itemsToTranslate.length === 0){
                        this.logMessage('No titles require translation right now.');
                        // still update DOM to use translatedTitle if any exist
                        for(const item of this.feedMap.values()) this.updateItemInDOM(item);
                        return;
                    }

                    this.translationInProgress = true;
                    this.translationProgress.style.display = 'block';
                    const total = itemsToTranslate.length;
                    let done = 0;
                    this.translationProgressText.textContent = `0/${total}`;
                    this.translationProgressFill.style.width = `0%`;

                    for(const item of itemsToTranslate){
                        // allow user to cancel by toggling the checkbox off
                        if(!this.isTranslationEnabled){
                            this.logMessage('Translation cancelled by user.');
                            break;
                        }
                        try{
                            const translated = await this.translateTitle(item.originalTitle);
                            item.translatedTitle = translated;
                            this.feedMap.set(item.id, item);
                            // update DOM so users see translated title as it finishes
                            this.updateItemInDOM(item);
                        }catch(e){
                            this.logMessage('Translation error for item: ' + (e.message || e));
                        }
                        done++;
                        const pct = Math.round((done/total)*100);
                        this.translationProgressFill.style.width = pct + '%';
                        this.translationProgressText.textContent = `${done}/${total}`;
                    }

                    // finished or cancelled
                    this.translationInProgress = false;
                    setTimeout(()=>{ this.translationProgress.style.display = 'none'; }, 600);
                    this.logMessage('Translation finished or stopped.');
                } else {
                    // disabled -> revert DOM to original titles
                    for(const item of this.feedMap.values()) this.updateItemInDOM(item);
                }
            });
        }

        setupDebugToggle(){
            this.debugSwitch.addEventListener('change', ()=>{
                this.isDebugging = this.debugSwitch.checked;
                this.debugLogElement.style.display = this.isDebugging ? 'block' : 'none';
                this.logMessage('Debug mode ' + (this.isDebugging ? 'started' : 'stopped'));
            });
        }

        setupFilterControls(){
            const filterButtons = document.querySelectorAll('.filter-button');
            filterButtons.forEach(btn => btn.addEventListener('click', ()=>{
                filterButtons.forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
                this.currentFilter = btn.dataset.filter;
                // apply filter by showing/hiding items
                this.applyFilter();
            }));
        }

        applyFilter(){
            const allItems = document.querySelectorAll('.feed-item');
            allItems.forEach(node=>{
                this.applyFilterToNode(node);
            });
        }

        applyFilterToNode(node){
            const vid = node.dataset.videoId;
            // if videoId empty, try id lookup
            const id = node.dataset.id;
            const item = Array.from(this.feedMap.values()).find(i => (i.videoId === vid && vid) || i.id === id);
            if(!item) return;
            let show = true;
            if(this.currentFilter === 'released'){
                show = !item.liveStreamingDetails || (item.liveStreamingDetails && item.liveStreamingDetails.actualEndTime);
            } else if(this.currentFilter === 'unreleased'){
                show = item.liveStreamingDetails && !item.liveStreamingDetails.actualEndTime;
            }
            node.style.display = show ? '' : 'none';
        }

        setupThemeSwitch(){
            const themeSwitch = document.getElementById('themeSwitch');
            const themeIcon = document.getElementById('themeIcon');
            themeSwitch.addEventListener('click', ()=>{
                if(document.body.classList.contains('light-theme')){
                    document.body.classList.replace('light-theme','dark-theme'); themeIcon.textContent = '‚òÄÔ∏è'; localStorage.setItem('theme','dark');
                } else {
                    document.body.classList.replace('dark-theme','light-theme'); themeIcon.textContent = 'üåô'; localStorage.setItem('theme','light');
                }
            });
            const saved = localStorage.getItem('theme');
            if(saved){ document.body.classList.remove('light-theme','dark-theme'); document.body.classList.add(saved+'-theme'); themeIcon.textContent = saved === 'dark' ? '‚òÄÔ∏è' : 'üåô'; }
            else if(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches){ document.body.classList.replace('light-theme','dark-theme'); themeIcon.textContent = '‚òÄÔ∏è'; }
        }

        /* ---------- translation helper (basic via Google translate free endpoint) ---------- */
        async translateTitle(text){
            if(!text || text.trim()==='') return 'No title';
            // If looks ascii, skip
            if(/^[\x00-\x7F]+$/.test(text)) return text;
            try{
                const resp = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=ml&tl=en&dt=t&q=${encodeURIComponent(text)}`);
                if(!resp.ok) throw new Error('Translate API ' + resp.status);
                const data = await resp.json();
                const translated = data[0][0][0];
                return translated || text;
            }catch(err){
                this.logMessage('Translation failed: ' + err.message);
                return text;
            }
        }
    }

    // bootstrap
    document.addEventListener('DOMContentLoaded', ()=>{
        window.app = new RSSFeedReader();
    });
    </script>
</body>
</html>
