<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>YouTube RSS Feed Reader</title>
  <style>
    /* Material You expressive-ish palette */
    :root{
      --primary:#6750A4;
      --on-primary:#FFF;
      --primary-container:#EADDFF;
      --on-primary-container:#21005D;
      --secondary:#625B71;
      --surface:#1C1B1F;
      --surface-light:#FFFBFE;
      --text:#E6E1E5;
      --text-secondary:#CFC6DC;
      --error:#F44336;
      --no-stats-bg:#2C2020;
      --no-stats-border:#8C1D18;
    }
    body{font-family: "Google Sans", "Segoe UI", Tahoma, Arial; margin:0;padding:20px;background:var(--surface);color:var(--text);min-height:100vh;}
    .container{max-width:1200px;margin:0 auto}
    .header{padding:18px;border-radius:14px;background:linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 8px 30px rgba(0,0,0,0.25)}
    .header h1{margin:0;color:var(--primary);font-size:1.6rem}
    .status{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;align-items:center}
    .status-item{background:rgba(255,255,255,0.02);padding:8px 12px;border-radius:999px;color:var(--text-secondary);font-weight:600;display:flex;gap:8px;align-items:center}
    .status-indicator{width:12px;height:12px;border-radius:50%;background:#bdbdbd;display:inline-block}
    .status-indicator.loading{background:#ff9800;animation:pulse 2s infinite}
    .status-indicator.connected{background:#4caf50}
    .status-indicator.error{background:var(--error)}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.5}}

    .filter-controls{display:flex;gap:8px;margin-top:12px}
    .filter-button{padding:8px 12px;border-radius:999px;border:2px solid var(--primary);background:transparent;color:var(--primary);cursor:pointer;font-weight:700}
    .filter-button.active{background:var(--primary);color:var(--on-primary);transform:translateY(-2px);box-shadow:0 8px 20px rgba(0,0,0,0.2)}

    .feed-container{margin-top:18px;padding:16px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 14px 40px rgba(0,0,0,0.25)}
    .loading{padding:30px;text-align:center;color:var(--primary)}
    .spinner{width:36px;height:36px;border-radius:50%;border:4px solid rgba(255,255,255,0.08);border-top-color:var(--primary);animation:spin 1s linear infinite;margin:0 auto 8px}
    @keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}

    .feed-list{display:flex;flex-direction:column;gap:12px}
    .feed-item{display:flex;gap:14px;align-items:flex-start;padding:12px;border-radius:12px;border-left:6px solid var(--primary);background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));transition:transform .12s,box-shadow .12s}
    .feed-item:hover{transform:translateY(-4px);box-shadow:0 18px 40px rgba(0,0,0,0.25)}
    .feed-item.no-stats-post{background:var(--no-stats-bg);border-left-color:var(--no-stats-border)}
    .feed-thumbnail-container{width:200px;height:112px;flex-shrink:0;border-radius:10px;overflow:hidden;position:relative;cursor:pointer}
    .feed-thumbnail{width:100%;height:100%;object-fit:cover;display:block}
    .play-icon{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
    .play-icon::after{content:'';border-style:solid;border-width:16px 0 16px 26px;border-color:transparent transparent transparent rgba(255,255,255,0.95)}
    .iframe-container{width:200px;height:112px;border-radius:10px;overflow:hidden;flex-shrink:0}
    .feed-content{flex:1;min-width:0}
    .feed-title{font-weight:700;font-size:1.05rem;margin-bottom:6px}
    .feed-date{color:var(--text-secondary);font-weight:600;margin-bottom:8px;display:flex;gap:10px;flex-wrap:wrap}
    .feed-description{color:var(--text-secondary);line-height:1.45;margin-bottom:10px}
    .actions{display:flex;gap:8px;flex-wrap:wrap}
    .action-button{padding:8px 12px;border-radius:999px;border:none;cursor:pointer;background:var(--primary);color:var(--on-primary);font-weight:700}
    .action-button.copy{background:var(--secondary);color:#fff}
    .action-button.advanced{background:transparent;border:2px solid var(--primary);color:var(--primary);}

    /* modal */
    .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.45);align-items:center;justify-content:center;z-index:300}
    .modal-content{background:var(--surface);padding:18px;border-radius:12px;min-width:320px;color:var(--text)}
    .close-button{position:absolute;right:16px;top:12px;cursor:pointer;color:var(--text-secondary)}

    /* debug */
    #debugLog{margin-top:16px;padding:12px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));font-family:monospace;color:var(--text-secondary)}
    #debugLog h4{color:var(--primary);margin:0 0 8px 0}
    #debugLog pre{max-height:220px;overflow:auto;background:transparent;color:var(--text-secondary)}
    .timer-row{display:flex;gap:12px;align-items:center;margin-bottom:10px;font-weight:700;color:var(--text-secondary)}
    .timer-chip{background:rgba(255,255,255,0.02);padding:6px 10px;border-radius:999px}

    /* translation progress */
    .progress-track{width:100%;height:10px;background:rgba(255,255,255,0.03);border-radius:999px;overflow:hidden;margin-top:8px}
    .progress-fill{height:100%;width:0;background:linear-gradient(90deg,var(--primary), color-mix(in srgb,var(--primary) 60%, black 10%));transition:width .2s}

    @media(max-width:800px){ .feed-thumbnail-container,.iframe-container{width:100%;height:auto;min-height:160px} .feed-item{flex-direction:column}}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé• YouTube RSS Feed Reader</h1>
      <div class="status">
        <div class="status-item"><span id="statusIndicator" class="status-indicator loading"></span> <span>Status: <b id="status">Loading...</b></span></div>
        <div class="status-item">üìÖ Last Update: <b id="lastUpdate">Never</b></div>
        <div class="status-item">üìä Total Posts: <b id="totalPosts">0</b></div>
        <div class="status-item">üîî New Posts: <b id="newPosts">0</b></div>
        <button id="advancedSettingsButton" class="action-button advanced">‚öôÔ∏è Advanced</button>
      </div>

      <div class="filter-controls">
        <button class="filter-button active" data-filter="all">All</button>
        <button class="filter-button" data-filter="released">Released</button>
        <button class="filter-button" data-filter="unreleased">Unreleased</button>
      </div>
    </div>

    <div class="feed-container">
      <div id="feedContent">
        <div class="loading"><div class="spinner"></div>Loading RSS feed...</div>
      </div>

      <div id="debugLog">
        <h4>Debug Log</h4>
        <div class="timer-row">
          <div class="timer-chip">Next feed check: <span id="feedTimer">--:--</span></div>
          <div class="timer-chip">Next YouTube API: <span id="ytTimer">--:--</span></div>
        </div>
        <pre id="logContent"></pre>
      </div>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="settingsModal" class="modal">
    <div class="modal-content">
      <span id="closeModalButton" class="close-button">&times;</span>
      <h3>Advanced Settings</h3>
      <div style="display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid rgba(255,255,255,0.03)">
        <div>Debug Mode</div>
        <label><input type="checkbox" id="debugSwitch" checked> <span style="margin-left:8px">Enabled</span></label>
      </div>
      <div style="display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px solid rgba(255,255,255,0.03)">
        <div>Translation (ml ‚Üí en)</div>
        <label><input type="checkbox" id="translationSwitch"> <span style="margin-left:8px">Enabled</span></label>
      </div>
      <div id="translationProgress" style="display:none;margin-top:10px">
        <div style="font-weight:700;margin-bottom:6px">Translating titles... <span id="translationProgressText">0/0</span></div>
        <div class="progress-track"><div id="translationProgressFill" class="progress-fill"></div></div>
      </div>
    </div>
  </div>

  <!-- Message modal -->
  <div id="messageModal" class="modal">
    <div class="modal-content">
      <div id="messageText"></div>
      <div style="text-align:right;margin-top:10px"><button id="closeMessageModalButton" class="action-button">OK</button></div>
    </div>
  </div>

  <audio id="notificationSound" src="https://raw.githubusercontent.com/ravanabackup/candle/refs/heads/main/ding.mp3"></audio>

  <script>
  class RSSFeedReader {
    constructor(){
      // Config
      this.feedUrl = 'https://cors.kawiesh.top/https://www.youtube.com/feeds/videos.xml?channel_id=UCbg8V1kty3s1kcCch2VHwEw';
      this.YT_API_KEY = 'AIzaSyAzDe7gqM5P_cGwxreEVtzAbrk-5BubrcM';
      this.pollIntervalMs = 60000;              // 60s feed poll
      this.forceStatusIntervalMs = 5*60*1000;   // 5min forced YT status when feed empty

      // State
      this.knownItemsKey = 'rss-known-items';
      this.knownItems = this.loadKnownItems();
      this.feedMap = new Map(); // id -> item
      this.newItemsCount = 0;
      this.originalTitle = document.title;
      this.currentFilter = 'all';
      this.isDebugging = true;
      this.isTranslationEnabled = false;
      this.translationInProgress = false;

      // DOM handles
      this.feedContent = document.getElementById('feedContent');
      this.logContentElement = document.getElementById('logContent');
      this.debugLogElement = document.getElementById('debugLog');
      this.debugSwitch = document.getElementById('debugSwitch');
      this.translationSwitch = document.getElementById('translationSwitch');
      this.translationProgress = document.getElementById('translationProgress');
      this.translationProgressFill = document.getElementById('translationProgressFill');
      this.translationProgressText = document.getElementById('translationProgressText');
      this.notificationSound = document.getElementById('notificationSound');

      // timers
      this.updateInterval = null;
      this.forceStatusTimer = null;
      this.debugTimerInterval = null;

      // Next usage timestamps
      this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;
      this.nextYTApiAt = null; // set when YT API called (cooldown)

      this.init();
    }

    init(){
      this.setupThemeSwitch();
      this.setupModal();
      this.setupFilterControls();
      this.setupDebugToggle();

      // start debug timers visible
      this.debugLogElement.style.display = this.isDebugging ? 'block' : 'none';
      this.startDebugTimers();

      // initial fetch
      this.fetchFeed();

      // poll
      this.updateInterval = setInterval(()=>this.fetchFeed(), this.pollIntervalMs);
    }

    /* ---------- timers for debug UI ---------- */
    startDebugTimers(){
      // Clear if exists
      if(this.debugTimerInterval) clearInterval(this.debugTimerInterval);
      // show immediately
      this.updateDebugTimersDisplay();
      // update every second
      this.debugTimerInterval = setInterval(()=>this.updateDebugTimersDisplay(), 1000);
    }

    updateDebugTimersDisplay(){
      const feedTimerEl = document.getElementById('feedTimer');
      const ytTimerEl = document.getElementById('ytTimer');

      // feed timer
      const now = Date.now();
      const feedLeftMs = Math.max(0, (this.nextFeedFetchAt || (now + this.pollIntervalMs)) - now);
      feedTimerEl.textContent = this.formatMsToCountdown(feedLeftMs);

      // yt timer
      if(this.nextYTApiAt && this.nextYTApiAt > now){
        const ytLeftMs = this.nextYTApiAt - now;
        ytTimerEl.textContent = this.formatMsToCountdown(ytLeftMs);
      } else {
        ytTimerEl.textContent = '--:--';
      }
    }

    formatMsToCountdown(ms){
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const sec = s % 60;
      return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    }

    /* ---------- localStorage ---------- */
    loadKnownItems(){
      const stored = localStorage.getItem(this.knownItemsKey);
      try{ return stored ? new Set(JSON.parse(stored)) : new Set(); }
      catch(e){ console.error('parse known',e); return new Set(); }
    }
    saveKnownItems(){ localStorage.setItem(this.knownItemsKey, JSON.stringify(Array.from(this.knownItems))); }

    /* ---------- logging ---------- */
    logMessage(msg){
      if(!this.isDebugging) return;
      const now = new Date().toLocaleTimeString('en-GB');
      this.logContentElement.textContent += `[${now}] ${msg}\n`;
      this.logContentElement.scrollTop = this.logContentElement.scrollHeight;
    }

    /* ---------- fetch & process ---------- */
    async fetchFeed(){
      this.logMessage('Starting feed fetch...');
      document.getElementById('status').textContent = 'Fetching...';
      document.getElementById('statusIndicator').className = 'status-indicator loading';

      // set next feed fetch time immediately
      this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;

      try{
        const r = await fetch(this.feedUrl);
        if(!r.ok) throw new Error('HTTP ' + r.status);
        const xmlText = await r.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlText, 'text/xml');
        this.logMessage('Feed XML parsed');
        const { items, idsInFeed } = this.parseFeedXml(xml);

        // diff
        const newIds = idsInFeed.filter(id => !this.feedMap.has(id));
        const removedIds = Array.from(this.feedMap.keys()).filter(id => !idsInFeed.includes(id));

        this.logMessage(`Entries: ${items.length}. New: ${newIds.length}, Removed: ${removedIds.length}`);

        // remove missing
        removedIds.forEach(id=>{
          this.feedMap.delete(id);
          this.removeItemFromDOM(id);
          this.knownItems.delete(id);
        });
        this.saveKnownItems();

        // add/merge
        const newItems = [];
        for(const it of items){
          const prev = this.feedMap.get(it.id);
          if(!prev){
            this.feedMap.set(it.id, it);
            newItems.push(it);
          } else {
            // carefully merge preserving liveStreamingDetails and translations and non-zero community stats
            const merged = Object.assign({}, prev, it);
            merged.liveStreamingDetails = (it.liveStreamingDetails !== null && it.liveStreamingDetails !== undefined) ? it.liveStreamingDetails : (prev.liveStreamingDetails || null);
            merged.translatedTitle = prev.translatedTitle || it.translatedTitle || null;
            const itViews = it.community && it.community.views ? parseInt(it.community.views) : 0;
            const prevViews = prev.community && prev.community.views ? parseInt(prev.community.views) : 0;
            merged.community = (!it.community || itViews === 0) ? (prev.community || it.community) : it.community;
            this.feedMap.set(it.id, merged);

            // update DOM only when meaningful
            const changed = (prev.title !== merged.title) || (prev.summary !== merged.summary) || (JSON.stringify(prev.liveStreamingDetails) !== JSON.stringify(merged.liveStreamingDetails)) || (prev.translatedTitle !== merged.translatedTitle);
            if(changed) this.updateItemInDOM(merged);
          }
        }

        // insert new items into DOM and mark known (so no duplicate notify)
        if(newItems.length > 0){
          this.logMessage(`${newItems.length} new items detected`);
          newItems.forEach(it => { this.knownItems.add(it.id); });
          this.saveKnownItems();
          newItems.forEach(it => this.insertItemToDOM(it, true));
          // call YT API only for new video IDs
          const newVideoIds = newItems.map(i => i.videoId).filter(Boolean);
          if(newVideoIds.length > 0) {
            await this.getLiveStatusForVideoIds(newVideoIds);
            // set next YT API allowed time to 5 minutes from now
            this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
          }
          this.playNotificationSound();
        } else {
          this.logMessage('No new items in this fetch.');
        }

        // if nothing, schedule forced YT checks
        if(this.feedMap.size === 0){
          this.logMessage('Feed empty ‚Äî scheduling forced YT checks.');
          this.scheduleForceStatusChecks();
        } else {
          this.clearForceStatusChecks();
        }

        // update UI & timers
        this.updateTotalPosts();
        document.getElementById('status').textContent = 'Connected';
        document.getElementById('statusIndicator').className = 'status-indicator connected';
        this.updateLastUpdateTime();
        this.updateTitle();
        this.applyFilter();
      } catch(err){
        console.error(err);
        this.logMessage('Feed fetch error: ' + err.message);
        document.getElementById('status').textContent = 'Error';
        document.getElementById('statusIndicator').className = 'status-indicator error';
        this.showError('Failed to load RSS feed: ' + err.message);
      }
    }

    parseFeedXml(xmlDoc){
      const entries = Array.from(xmlDoc.querySelectorAll('entry'));
      const items = [];
      const idsInFeed = [];
      for(const entry of entries){
        const id = entry.querySelector('id')?.textContent || '';
        if(!id) continue;
        if(idsInFeed.includes(id)) continue;
        idsInFeed.push(id);
        const originalTitle = entry.querySelector('title')?.textContent || 'No title';
        const link = entry.querySelector('link')?.getAttribute('href') || '#';
        const published = entry.querySelector('published')?.textContent || '';
        const updated = entry.querySelector('updated')?.textContent || '';
        const mediaGroup = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'group')[0];
        let summary = entry.querySelector('summary')?.textContent || 'No description available';
        if(mediaGroup){
          const desc = mediaGroup.getElementsByTagNameNS('http://search.yahoo.com/mrss/','description')[0];
          if(desc && desc.textContent.trim() !== '') summary = desc.textContent;
        }
        const community = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/','community')[0];
        const starRating = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/','starRating')[0]?.getAttribute('average') || '0.00';
        const ratingCount = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/','starRating')[0]?.getAttribute('count') || '0';
        const views = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/','statistics')[0]?.getAttribute('views') || '0';

        const videoId = this.extractVideoId(link);
        const thumbnail = videoId ? `https://cors.kawiesh.top/https://i2.ytimg.com/vi/${videoId}/hqdefault.jpg` : null;
        const isNew = !this.knownItems.has(id);
        const hasStats = parseInt(views) > 0;

        const item = {
          id,
          title: originalTitle,
          originalTitle: originalTitle,
          translatedTitle: null,
          link,
          published: this.parseDateTime(published),
          updated: this.parseDateTime(updated),
          summary: this.cleanSummary(summary),
          thumbnail,
          community: { starRating, ratingCount, views },
          isNew,
          hasStats,
          videoId,
          liveStreamingDetails: null
        };
        items.push(item);
      }
      items.sort((a,b)=> new Date(b.published.full) - new Date(a.published.full));
      return { items, idsInFeed };
    }

    /* ---------- YouTube API ---------- */
    async getLiveStatusForVideoIds(videoIdList){
      if(!this.YT_API_KEY || this.YT_API_KEY === 'YOUR_YOUTUBE_API_KEY_HERE'){
        this.logMessage('YouTube API key not configured ‚Äî skipping.');
        return;
      }
      if(!videoIdList || videoIdList.length===0) return;
      const chunks=[];
      for(let i=0;i<videoIdList.length;i+=50) chunks.push(videoIdList.slice(i,i+50));
      try{
        for(const chunk of chunks){
          const parts='id,liveStreamingDetails';
          const url = `https://www.googleapis.com/youtube/v3/videos?part=${parts}&id=${chunk.join(',')}&key=${this.YT_API_KEY}`;
          this.logMessage(`Calling YouTube API for ${chunk.length} videos...`);
          const res = await fetch(url);
          if(!res.ok){ this.logMessage('YouTube API error ' + res.status); continue; }
          const data = await res.json();
          if(!data.items) continue;
          for(const obj of data.items){
            const vid = obj.id;
            const liveDetails = obj.liveStreamingDetails || null;
            for(const [id,item] of this.feedMap.entries()){
              if(item.videoId === vid){
                item.liveStreamingDetails = liveDetails;
                this.feedMap.set(id,item);
                this.logMessage('Merged live details for ' + vid);
                this.updateItemInDOM(item);
              }
            }
          }
        }
        // set next YT API allowed time as cooldown (5 minutes)
        this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
      }catch(err){
        console.error(err);
        this.logMessage('YT API error: ' + err.message);
      }
    }

    scheduleForceStatusChecks(){
      if(this.forceStatusTimer) return;
      this.forceStatusTimer = setInterval(async ()=>{
        this.logMessage('Forced YT check (feed empty).');
        const knownVideoIds = Array.from(this.feedMap.values()).map(i=>i.videoId).filter(Boolean);
        if(knownVideoIds.length>0) await this.getLiveStatusForVideoIds(knownVideoIds);
        else this.logMessage('No known video ids to check.');
      }, this.forceStatusIntervalMs);
    }
    clearForceStatusChecks(){
      if(this.forceStatusTimer){ clearInterval(this.forceStatusTimer); this.forceStatusTimer=null; this.logMessage('Cleared forced YT checks.'); }
    }

    /* ---------- DOM helpers ---------- */
    makeItemHtml(item){
      const displayTitle = (this.isTranslationEnabled && item.translatedTitle) ? item.translatedTitle : item.originalTitle;
      let dateDisplay = '';
      let communityHtml = '';
      let postClass = item.isNew ? ' new' : '';
      let copyDate = item.published?.date || '';
      let copyTime = item.published?.time || '';

      if(item.liveStreamingDetails){
        const l = item.liveStreamingDetails;
        if(l.actualStartTime && !l.actualEndTime){
          dateDisplay = 'üî¥ Live Now';
          communityHtml = `<div class="date-item">üìà <b>Community Stats:</b> Live stream in progress!</div>`;
          postClass += ' no-stats-post';
        } else if(l.scheduledStartTime && !l.actualStartTime){
          const sched = this.parseDateTime(l.scheduledStartTime);
          dateDisplay = `‚è∞ Scheduled: ${sched.date} ${sched.time}`;
          copyDate = sched.date; copyTime = sched.time;
          postClass += ' no-stats-post';
        } else if(l.actualStartTime){
          const started = this.parseDateTime(l.actualStartTime);
          dateDisplay = `üìÖ Published: ${started.date} ${started.time}`;
          copyDate = started.date; copyTime = started.time;
          if(item.updated) dateDisplay += ` | üîÑ Updated: ${item.updated.date} ${item.updated.time}`;
          const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views || 0);
          const starRating = '‚≠ê'.repeat(Math.round(parseFloat(item.community.starRating||0)));
          communityHtml = `<div class="date-item">üìà <b>Community Stats:</b><br>${starRating} (${item.community.starRating} avg from ${item.community.ratingCount})<br>üëÄ Views: ${formattedViews}</div>`;
        }
      } else {
        dateDisplay = `üìÖ Published: ${item.published?.date || 'Unknown'} ${item.published?.time || ''}`;
        if(item.updated) dateDisplay += ` | üîÑ Updated: ${item.updated.date} ${item.updated.time}`;
        if(item.hasStats){
          const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views || 0);
          const starRating = '‚≠ê'.repeat(Math.round(parseFloat(item.community.starRating||0)));
          communityHtml = `<div class="date-item">üìà <b>Community Stats:</b><br>${starRating} (${item.community.starRating} avg from ${item.community.ratingCount})<br>üëÄ Views: ${formattedViews}</div>`;
        } else {
          communityHtml = `<div class="date-item">üìà <b>Community Stats:</b> Not yet available</div>`;
          postClass += ' no-stats-post';
        }
      }

      const descriptionHtml = item.hasStats ? `<div class="feed-description">${this.escapeHtml(item.summary)}</div>` : '';
      const thumbHtml = item.thumbnail ? `
        <div class="feed-thumbnail-container" data-video-id="${this.escapeHtml(item.videoId||'')}" style="min-width:200px">
          <img src="${this.escapeHtml(item.thumbnail)}" class="feed-thumbnail" alt="${this.escapeHtml(displayTitle)}" onerror="this.style.display='none'"/>
          <div class="play-icon"></div>
        </div>` : '';

      return `
        <div class="feed-item${postClass}" data-id="${this.escapeHtml(item.id)}" data-video-id="${this.escapeHtml(item.videoId||'')}" data-video-link="${this.escapeHtml(item.link)}">
          <div class="feed-item-content" style="display:flex;gap:14px;align-items:flex-start;width:100%">
            ${thumbHtml}
            <div class="feed-content">
              <div class="feed-title">${this.escapeHtml(displayTitle)}</div>
              <div class="feed-date"><div class="date-item">${dateDisplay}</div></div>
              ${descriptionHtml}
              ${communityHtml}
              <div class="actions">
                <a class="action-button" href="${this.escapeHtml(item.link)}" target="_blank" onclick="event.stopPropagation()">üé¨ Watch Video</a>
                <button class="action-button copy" onclick="event.stopPropagation(); window.app.copyToClipboardById('${this.jsEscape(item.id)}')">üìã Copy Info</button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    insertItemToDOM(item, prepend=false){
      const div = document.createElement('div');
      div.innerHTML = this.makeItemHtml(item);
      const node = div.firstElementChild;
      if(!node) return;
      const list = this.getOrCreateFeedList();
      if(prepend) list.insertBefore(node, list.firstChild); else list.appendChild(node);
      this.attachThumbnailHandler(node);
      this.applyFilterToNode(node);
    }

    updateItemInDOM(item){
      const selector = `.feed-item[data-id="${this.escapeCssSelector(item.id)}"]`;
      const existing = document.querySelector(selector);
      if(!existing){ this.insertItemToDOM(item,true); return; }
      const wrapper = document.createElement('div');
      wrapper.innerHTML = this.makeItemHtml(item);
      const newNode = wrapper.firstElementChild;
      existing.replaceWith(newNode);
      this.attachThumbnailHandler(newNode);
      this.applyFilterToNode(newNode);
    }

    removeItemFromDOM(id){
      const node = document.querySelector(`.feed-item[data-id="${this.escapeCssSelector(id)}"]`);
      if(node) node.remove();
    }

    getOrCreateFeedList(){
      let list = document.querySelector('.feed-list');
      if(!list){ this.feedContent.innerHTML = ''; list = document.createElement('div'); list.className = 'feed-list'; this.feedContent.appendChild(list); }
      return list;
    }

    attachThumbnailHandler(root){
      const thumb = root.querySelector('.feed-thumbnail-container');
      if(!thumb) return;
      thumb.addEventListener('click', ev=>{
        const videoId = thumb.dataset.videoId;
        if(videoId){
          const iframe = this.createIframeWrapper(videoId);
          thumb.replaceWith(iframe);
        }
        ev.stopPropagation();
      });
    }

    createIframeWrapper(videoId){
      const wrapper = document.createElement('div');
      wrapper.className = 'iframe-container';
      const iframe = document.createElement('iframe');
      iframe.width = "200"; iframe.height = "112";
      iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
      iframe.frameBorder = "0";
      iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
      iframe.allowFullscreen = true;
      wrapper.appendChild(iframe);
      return wrapper;
    }

    /* ---------- copy behavior ---------- */
    copyToClipboardById(id){
      const item = Array.from(this.feedMap.values()).find(i=>i.id===id);
      if(!item) return;
      const title = (this.isTranslationEnabled && item.translatedTitle) ? item.translatedTitle : item.originalTitle;
      const isLiveNow = item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime;
      let date = item.published?.date || '';
      let time = item.published?.time || '';
      // if live actual start exists, show that time
      if(item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime){
        const dt = this.parseDateTime(item.liveStreamingDetails.actualStartTime);
        date = dt.date; time = dt.time;
      }
      let textToCopy;
      if(isLiveNow){
        // special format required
        textToCopy = `Title: ${title}\nüî¥ Live Now\n\nDate: ${date} ${time}\nURL: ${item.link}`;
      } else {
        textToCopy = `Title: ${title}\n\nDate: ${date} ${time}\nURL: ${item.link}`;
      }
      this.copyRawText(textToCopy);
      this.showMessageBox('Video info copied to clipboard!');
    }

    copyRawText(text){
      const ta = document.createElement('textarea');
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand('copy'); } catch(e){ this.logMessage('Copy failed: ' + e.message); }
      ta.remove();
    }

    /* ---------- misc UI ---------- */
    playNotificationSound(){ if(this.notificationSound){ try{ this.notificationSound.currentTime=0; this.notificationSound.play().catch(e=>this.logMessage('Sound blocked: '+e.message)); }catch(e){ this.logMessage('Sound err: '+e.message); } } }
    updateTitle(){ const newCount = Array.from(this.feedMap.values()).filter(i=>i.isNew).length; this.newItemsCount=newCount; document.title = newCount>0 ? `(${newCount}) New Posts - ${this.originalTitle}` : this.originalTitle; }
    updateLastUpdateTime(){ const now=new Date(); const opts={day:'2-digit',month:'2-digit',year:'numeric',hour:'2-digit',minute:'2-digit',second:'2-digit'}; document.getElementById('lastUpdate').textContent = now.toLocaleString('en-GB',opts); }
    updateTotalPosts(){ document.getElementById('totalPosts').textContent = this.feedMap.size; document.getElementById('newPosts').textContent = this.newItemsCount;
      const allCount = this.feedMap.size;
      const releasedCount = Array.from(this.feedMap.values()).filter(item => !item.liveStreamingDetails || (item.liveStreamingDetails && item.liveStreamingDetails.actualEndTime)).length;
      const unreleasedCount = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && !item.liveStreamingDetails.actualEndTime).length;
      document.querySelector('[data-filter="all"]').textContent = `All (${allCount})`;
      document.querySelector('[data-filter="released"]').textContent = `Released (${releasedCount})`;
      document.querySelector('[data-filter="unreleased"]').textContent = `Unreleased (${unreleasedCount})`;
    }
    showError(message){ this.feedContent.innerHTML = `<div style="padding:12px;border-radius:8px;background:rgba(255,0,0,0.06);color:var(--error)">${this.escapeHtml(message)}</div>`; }
    showMessageBox(msg){ const modal = document.getElementById('messageModal'); document.getElementById('messageText').textContent = msg; modal.style.display='flex'; }

    /* ---------- utils ---------- */
    extractVideoId(url){ const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/; const m=url?.match(regex); return m?m[1]:null; }
    parseDateTime(dateString){ if(!dateString) return {date:'',time:'',full:null}; const d=new Date(dateString); const options={year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit',hour12:true,timeZone:'Asia/Kolkata'}; const fmt=new Intl.DateTimeFormat('en-GB',options); const parts=fmt.formatToParts(d); const dateFormatted=`${parts.find(p=>p.type==='day').value}-${parts.find(p=>p.type==='month').value}-${parts.find(p=>p.type==='year').value}`; const timeFormatted=`${parts.find(p=>p.type==='hour').value}:${parts.find(p=>p.type==='minute').value}:${parts.find(p=>p.type==='second').value} ${parts.find(p=>p.type==='dayPeriod').value}`; return {date:dateFormatted,time:timeFormatted,full:d.toString()}; }
    cleanSummary(s){ if(!s) return ''; const c=s.replace(/<[^>]*>/g,'').trim(); return c.length>200?c.substring(0,200)+'...':c; }
    escapeHtml(t){ const d=document.createElement('div'); d.textContent=t; return d.innerHTML; }
    jsEscape(s){ if(!s) return ''; return s.replace(/\\/g,'\\\\').replace(/'/g,"\\'").replace(/\n/g,'\\n').replace(/\r/g,''); }
    escapeCssSelector(s){ if(window.CSS && CSS.escape) return CSS.escape(s); return s.replace(/(["\\])/g,'\\$1'); }

    /* ---------- translation ---------- */
    async translateTitle(text){
      if(!text || text.trim()==='') return 'No title';
      // skip ascii-only
      if(/^[\x00-\x7F]+$/.test(text)) return text;
      try{
        const resp = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=ml&tl=en&dt=t&q=${encodeURIComponent(text)}`);
        if(!resp.ok) throw new Error('Translate API ' + resp.status);
        const data = await resp.json();
        const translated = data[0][0][0];
        return translated || text;
      }catch(err){ this.logMessage('Translation failed: '+err.message); return text; }
    }

    /* ---------- UI wiring ---------- */
    setupModal(){
      const modal = document.getElementById('settingsModal');
      const advBtn = document.getElementById('advancedSettingsButton');
      const closeBtn = document.getElementById('closeModalButton');
      advBtn.addEventListener('click', ()=>modal.style.display='flex');
      closeBtn.addEventListener('click', ()=>modal.style.display='none');
      window.addEventListener('click', e=>{ if(e.target===modal) modal.style.display='none'; });
      document.getElementById('closeMessageModalButton').addEventListener('click', ()=>document.getElementById('messageModal').style.display='none');

      this.translationSwitch.addEventListener('change', async ()=>{
        this.isTranslationEnabled = this.translationSwitch.checked;
        this.logMessage('Translation toggled ' + (this.isTranslationEnabled ? 'on' : 'off'));
        if(this.isTranslationEnabled){
          const toTranslate = Array.from(this.feedMap.values()).filter(item => !item.translatedTitle);
          if(toTranslate.length === 0){
            this.logMessage('No titles to translate.');
            for(const item of this.feedMap.values()) this.updateItemInDOM(item);
            return;
          }
          // show progress
          this.translationInProgress = true;
          this.translationProgress.style.display='block';
          const total = toTranslate.length; let done=0;
          this.translationProgressText.textContent = `0/${total}`; this.translationProgressFill.style.width='0%';
          for(const item of toTranslate){
            if(!this.isTranslationEnabled){ this.logMessage('Translation cancelled'); break; }
            try{
              const tr = await this.translateTitle(item.originalTitle);
              item.translatedTitle = tr;
              this.feedMap.set(item.id,item);
              this.updateItemInDOM(item);
            }catch(e){ this.logMessage('Translate error: '+(e.message||e)); }
            done++;
            const pct=Math.round((done/total)*100);
            this.translationProgressFill.style.width = pct + '%';
            this.translationProgressText.textContent = `${done}/${total}`;
          }
          this.translationInProgress = false;
          setTimeout(()=>{ this.translationProgress.style.display='none'; }, 600);
          this.logMessage('Translation finished/stopped.');
        } else {
          // revert DOM to originals
          for(const item of this.feedMap.values()) this.updateItemInDOM(item);
        }
      });
    }

    setupDebugToggle(){
      this.debugSwitch.addEventListener('change', ()=>{
        this.isDebugging = this.debugSwitch.checked;
        this.debugLogElement.style.display = this.isDebugging ? 'block' : 'none';
        this.logMessage('Debug ' + (this.isDebugging ? 'on' : 'off'));
      });
    }

    setupFilterControls(){
      const filterButtons = document.querySelectorAll('.filter-button');
      filterButtons.forEach(btn => btn.addEventListener('click', ()=>{
        filterButtons.forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        this.currentFilter = btn.dataset.filter;
        this.applyFilter();
      }));
    }

    applyFilter(){
      const nodes = document.querySelectorAll('.feed-item');
      nodes.forEach(node => this.applyFilterToNode(node));
    }

    applyFilterToNode(node){
      const vid = node.dataset.videoId;
      const id = node.dataset.id;
      const item = Array.from(this.feedMap.values()).find(i => (i.videoId === vid && vid) || i.id === id);
      if(!item) return;
      let show = true;
      if(this.currentFilter === 'released') show = !item.liveStreamingDetails || (item.liveStreamingDetails && item.liveStreamingDetails.actualEndTime);
      else if(this.currentFilter === 'unreleased') show = item.liveStreamingDetails && !item.liveStreamingDetails.actualEndTime;
      node.style.display = show ? '' : 'none';
    }
  }

  // bootstrap
  document.addEventListener('DOMContentLoaded', ()=>{ window.app = new RSSFeedReader(); });
  </script>
</body>
</html>
