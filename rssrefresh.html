<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>YouTube RSS Feed Reader ‚Äî Futuristic</title>
<style>
  /* ---------- Futuristic / modern theme (neon glass) ---------- */
  :root{
    --bg-1: #08121a;
    --bg-2: #0b2a36;
    --card: rgba(255,255,255,0.04);
    --glass: rgba(255,255,255,0.03);
    --accent: #6EE7B7; /* mint */
    --accent-2: #7C6CFA; /* violet */
    --muted: #b8c6cf;
    --danger: #ff6b6b;
    --no-stats-bg: rgba(130,18,18,0.14);
  }
  html,body{height:100%;margin:0;font-family:Inter, "Segoe UI", Roboto, system-ui; background: radial-gradient(1200px 600px at 10% 10%, rgba(124,108,250,0.08), transparent), linear-gradient(135deg,var(--bg-1),var(--bg-2)); color:#e6f3ef; -webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}
  .wrap{max-width:1200px;margin:24px auto;padding:22px;}
  header{display:flex;align-items:center;gap:14px}
  .title{
    display:flex;flex-direction:column;
  }
  h1{margin:0;font-size:20px;color:var(--accent-2);letter-spacing:0.4px}
  p.sub{margin:2px 0 0 0;color:var(--muted);font-size:13px}

  /* top status box */
  .status-card{
    margin-top:18px;padding:14px;border-radius:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));box-shadow:0 12px 40px rgba(2,6,23,0.6);display:flex;gap:12px;align-items:center;flex-wrap:wrap;
  }
  .status-item{background:var(--glass);padding:8px 12px;border-radius:999px;color:var(--muted);font-weight:700;display:flex;align-items:center;gap:10px}
  .status-ind{width:12px;height:12px;border-radius:50%;background:#9aa7b0}
  .status-ind.loading{background: #f59e0b; animation:pulse 2s infinite}
  .status-ind.connected{background: #34d399}
  .status-ind.error{background: var(--danger)}
  @keyframes pulse{0%,100%{opacity:1}50%{opacity:.45}}

  /* filter */
  .filters{margin-top:12px;display:flex;gap:10px}
  .filter-btn{border-radius:999px;padding:8px 14px;border:1px solid rgba(255,255,255,0.05);background:transparent;color:var(--muted);cursor:pointer;font-weight:700}
  .filter-btn.active{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#021018;box-shadow:0 8px 28px rgba(124,108,250,0.12);transform:translateY(-2px)}

  /* feed container */
  .feed-container{margin-top:18px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:14px;box-shadow:0 18px 60px rgba(2,6,23,0.6)}
  .feed-list{display:flex;flex-direction:column;gap:12px}

  .feed-item{
    display:flex;gap:14px;align-items:flex-start;padding:14px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));border-left:6px solid rgba(124,108,250,0.6);transition:transform .14s, box-shadow .14s;
  }
  .feed-item:hover{transform:translateY(-6px);box-shadow:0 24px 60px rgba(2,6,23,0.5)}
  .feed-item.no-stats-post{background:var(--no-stats-bg);border-left-color:rgba(255,107,107,0.6)}

  .thumb{width:200px;height:112px;border-radius:10px;overflow:hidden;flex-shrink:0;position:relative;background:linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))}
  .thumb img{width:100%;height:100%;object-fit:cover;display:block}
  .play{position:absolute;inset:0;display:flex;align-items:center;justify-content:center}
  .play::after{content:'';border-style:solid;border-width:16px 0 16px 26px;border-color:transparent transparent transparent rgba(255,255,255,0.95)}

  .content{flex:1;min-width:0}
  .title-line{font-weight:800;font-size:1rem;color:linear-gradient(var(--accent),var(--accent-2));margin-bottom:6px}
  .meta{color:var(--muted);font-weight:700;margin-bottom:8px;display:flex;gap:12px;flex-wrap:wrap}
  .desc{color:var(--muted);margin-bottom:10px;line-height:1.45}
  .actions{display:flex;gap:8px;flex-wrap:wrap}
  .btn{padding:8px 12px;border-radius:999px;border:none;cursor:pointer;font-weight:800}
  .btn.watch{background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#021018}
  .btn.copy{background:transparent;border:2px solid rgba(255,255,255,0.06);color:var(--muted)}

  /* modal */
  .modal{display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:60}
  .modal .box{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:18px;border-radius:12px;width:420px;color:var(--muted);box-shadow:0 24px 60px rgba(2,6,23,0.8)}
  .row{display:flex;justify-content:space-between;align-items:center;padding:12px 0;border-bottom:1px dashed rgba(255,255,255,0.02)}
  .close-x{position:absolute;right:20px;top:20px;cursor:pointer;color:var(--muted)}

  /* debug box */
  #debug{margin-top:12px;padding:12px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.01), rgba(255,255,255,0.02));font-family:monospace;color:var(--muted)}
  .timers{display:flex;gap:8px;align-items:center;margin-bottom:10px}
  .timer-chip{background:rgba(255,255,255,0.02);padding:6px 10px;border-radius:999px;font-weight:800;color:var(--muted)}

  /* translation progress */
  .progress-track{height:10px; background:rgba(255,255,255,0.03); border-radius:999px; overflow:hidden}
  .progress-fill{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--accent-2));transition:width .22s}

  /* small screens */
  @media (max-width:820px){
    .feed-item{flex-direction:column}
    .thumb{width:100%;height:190px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>YouTube RSS Feed Reader</h1>
        <p class="sub">Realtime RSS viewer ‚Ä¢ incremental updates ‚Ä¢ translation progress ‚Ä¢ futuristic UI</p>
      </div>
    </header>

    <div class="status-card" role="status" aria-live="polite">
      <div class="status-item"><span id="statusIndicator" class="status-ind loading"></span> Status: <strong id="statusText" style="margin-left:6px">Loading...</strong></div>
      <div class="status-item">Last update: <strong id="lastUpdate" style="margin-left:6px">Never</strong></div>
      <div class="status-item">Total posts: <strong id="totalPosts" style="margin-left:6px">0</strong></div>
      <div class="status-item">New: <strong id="newPosts" style="margin-left:6px">0</strong></div>
      <button id="openSettings" class="status-item" style="cursor:pointer;background:linear-gradient(90deg,var(--accent),var(--accent-2));color:#021018;border:none">‚öôÔ∏è Settings</button>
      <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
        <div style="color:var(--muted);font-weight:700">Theme</div>
        <button id="themeToggle" class="status-item" style="cursor:pointer">üåô</button>
      </div>
    </div>

    <div class="filters">
      <button class="filter-btn active" data-filter="all">All (0)</button>
      <button class="filter-btn" data-filter="released">Released (0)</button>
      <button class="filter-btn" data-filter="unreleased">Unreleased (0)</button>
    </div>

    <div class="feed-container" id="feedContainer">
      <div id="feedList" class="feed-list">
        <div style="padding:28px;text-align:center;color:var(--muted)" id="loadingBox">
          <div style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.04);border-top-color:var(--accent);margin:0 auto 12px;animation:spin 1s linear infinite"></div>
          Loading RSS feed...
        </div>
      </div>
    </div>

    <!-- Debug area (visible by default) -->
    <div id="debug" aria-hidden="false">
      <div class="timers">
        <div class="timer-chip">Next feed check: <span id="feedTimer">--:--</span></div>
        <div class="timer-chip">Next YouTube API: <span id="ytTimer">--:--</span></div>
        <div class="timer-chip">Fetch candidate: <span id="lastCandidate" style="margin-left:6px">-</span></div>
      </div>
      <div id="debugLog" style="max-height:220px;overflow:auto;white-space:pre-wrap;font-size:12px;color:var(--muted)"></div>
    </div>
  </div>

  <!-- Settings modal -->
  <div id="modal" class="modal" aria-hidden="true">
    <div class="box" role="dialog" aria-modal="true">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <strong style="color:var(--accent-2)">Advanced Settings</strong>
        <button id="closeModal" class="close-x">‚úï</button>
      </div>

      <div class="row">
        <div style="font-weight:800">Debug Mode</div>
        <label><input type="checkbox" id="debugSwitch" checked> <span style="margin-left:8px;color:var(--muted)">On</span></label>
      </div>

      <div class="row">
        <div style="font-weight:800">Translation (ml ‚Üí en)</div>
        <label><input type="checkbox" id="translationSwitch"> <span style="margin-left:8px;color:var(--muted)">Enable</span></label>
      </div>

      <div id="translationProgressBox" style="display:none;padding-top:8px">
        <div style="font-weight:800;color:var(--muted)">Translating titles <span id="translationCount" style="font-weight:900">0/0</span></div>
        <div class="progress-track" style="margin-top:8px"><div id="translationFill" class="progress-fill"></div></div>
      </div>

      <div style="text-align:right;margin-top:12px">
        <button id="closeModalBtn" class="btn copy">Close</button>
      </div>
    </div>
  </div>

<script>
/* ##############################
   Complete YouTube RSS Reader
   - Save as HTML and open in browser
   - Replace YT_API_KEY with your key if you want live details
   ############################## */

class RSSFeedReader {
  constructor(config = {}) {
    // config
    this.channelFeedBase = config.feedBase || 'https://www.youtube.com/feeds/videos.xml?channel_id=UCbg8V1kty3s1kcCch2VHwEw';
    // CORS fallbacks (order of preference)
    this.feedCandidates = [
      this.channelFeedBase,
      'https://cors.kawiesh.top/' + this.channelFeedBase,
      'https://corsproxy.io/?' + encodeURIComponent(this.channelFeedBase),
      'https://api.allorigins.win/raw?url=' + encodeURIComponent(this.channelFeedBase)
    ];
    this.YT_API_KEY = config.YT_API_KEY || 'AIzaSyAzDe7gqM5P_cGwxreEVtzAbrk-5BubrcM'; // replace if available
    this.pollIntervalMs = config.pollIntervalMs || 60000; // 60s
    this.forceStatusIntervalMs = config.forceStatusIntervalMs || 5 * 60 * 1000; // 5 min

    // state
    this.knownItemsKey = 'rss-known-items-v1';
    this.knownItems = this.loadKnownItems();
    this.feedMap = new Map(); // id -> item
    this.isDebugging = true;
    this.isTranslationEnabled = false;
    this.translationInProgress = false;

    // timers & next times
    this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;
    // keep nextYTApiAt defined so debug never shows --:--
    this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;

    // DOM refs
    this.feedListEl = document.getElementById('feedList');
    this.loadingBox = document.getElementById('loadingBox');
    this.debugLogEl = document.getElementById('debugLog');
    this.feedTimerEl = document.getElementById('feedTimer');
    this.ytTimerEl = document.getElementById('ytTimer');
    this.lastCandidateEl = document.getElementById('lastCandidate');
    this.statusTextEl = document.getElementById('statusText');
    this.statusIndicatorEl = document.getElementById('statusIndicator');
    this.lastUpdateEl = document.getElementById('lastUpdate');
    this.totalPostsEl = document.getElementById('totalPosts');
    this.newPostsEl = document.getElementById('newPosts');

    this.translationFillEl = document.getElementById('translationFill');
    this.translationCountEl = document.getElementById('translationCount');
    this.translationProgressBox = document.getElementById('translationProgressBox');

    // audio: use WebAudio (no external URLs)
    this.audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;

    // timers
    this.fetchInterval = null;
    this.debugInterval = null;
    this.forceStatusTimer = null;

    // UI wiring
    this.setupUI();

    // start
    this.logMessage('App initializing...');
    this.fetchFeed(); // initial
    this.fetchInterval = setInterval(() => this.fetchFeed(), this.pollIntervalMs);
    this.debugInterval = setInterval(() => this.updateDebugTimers(), 1000);
  }

  /* ---------- storage ---------- */
  loadKnownItems() {
    try {
      const s = localStorage.getItem(this.knownItemsKey);
      return s ? new Set(JSON.parse(s)) : new Set();
    } catch (e) {
      console.error('loadKnownItems', e);
      return new Set();
    }
  }
  saveKnownItems() {
    localStorage.setItem(this.knownItemsKey, JSON.stringify(Array.from(this.knownItems)));
  }

  /* ---------- UI wiring ---------- */
  setupUI() {
    // modal
    document.getElementById('openSettings').addEventListener('click', () => this.openModal());
    document.getElementById('closeModal').addEventListener('click', () => this.closeModal());
    document.getElementById('closeModalBtn').addEventListener('click', () => this.closeModal());
    // debug toggle
    document.getElementById('debugSwitch').addEventListener('change', (e) => {
      this.isDebugging = e.target.checked;
      this.debugLogEl.parentElement.style.display = this.isDebugging ? '' : 'none';
    });
    // translation toggle
    document.getElementById('translationSwitch').addEventListener('change', async (e) => {
      this.isTranslationEnabled = e.target.checked;
      this.logMessage('Translation toggled ' + (this.isTranslationEnabled ? 'ON' : 'OFF'));
      if (this.isTranslationEnabled) await this.translateAllTitles();
      else this.renderAllItems(); // revert to original titles
    });
    // theme toggle (simple: invert accent)
    document.getElementById('themeToggle').addEventListener('click', () => {
      const root = document.documentElement;
      if (root.style.getPropertyValue('--accent') === '#6EE7B7') {
        root.style.setProperty('--accent', '#7C6CFA');
        root.style.setProperty('--accent-2', '#6EE7B7');
        document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
      } else {
        root.style.setProperty('--accent', '#6EE7B7');
        root.style.setProperty('--accent-2', '#7C6CFA');
        document.getElementById('themeToggle').textContent = 'üåô';
      }
    });

    // filter buttons
    document.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', (e) => {
      document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      this.applyFilter();
    }));

    // debug visibility
    document.getElementById('debug').style.display = '';
  }

  openModal() { document.getElementById('modal').style.display = 'flex'; }
  closeModal() { document.getElementById('modal').style.display = 'none'; }

  /* ---------- logging & debug ---------- */
  logMessage(msg) {
    if (!this.isDebugging) return;
    const ts = new Date().toLocaleTimeString('en-GB');
    this.debugLogEl.textContent += `[${ts}] ${msg}\n`;
    this.debugLogEl.scrollTop = this.debugLogEl.scrollHeight;
  }

  updateDebugTimers() {
    // feed timer
    const now = Date.now();
    const feedLeft = Math.max(0, this.nextFeedFetchAt - now);
    this.feedTimerEl.textContent = this.msToMMSS(feedLeft);
    // yt timer
    const ytLeft = Math.max(0, this.nextYTApiAt - now);
    this.ytTimerEl.textContent = this.msToMMSS(ytLeft);
  }
  msToMMSS(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const sec = s % 60;
    return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
  }

  /* ---------- robust fetch with CORS fallbacks ---------- */
  async tryFetchWithFallbacks() {
    let lastError = null;
    for (const candidate of this.feedCandidates) {
      try {
        this.logMessage(`Attempting fetch: ${candidate}`);
        this.lastCandidateEl.textContent = candidate;
        const r = await fetch(candidate, { cache: 'no-store' });
        if (!r.ok) {
          throw new Error('HTTP ' + r.status);
        }
        const text = await r.text();
        if (!text || text.indexOf('<feed') === -1) {
          this.logMessage('Response did not contain feed XML; skipping candidate.');
          lastError = new Error('No feed XML in response');
          continue;
        }
        return { text, candidate };
      } catch (err) {
        lastError = err;
        this.logMessage(`Candidate failed: ${err.message}`);
      }
    }
    throw lastError || new Error('All fetch attempts failed');
  }

  /* ---------- main feed fetch & processing ---------- */
  async fetchFeed() {
    try {
      this.logMessage('Starting feed fetch...');
      this.setStatus('Fetching...', 'loading');
      // schedule next feed check display
      this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;

      const { text: xmlText, candidate } = await this.tryFetchWithFallbacks();
      this.logMessage('Feed XML received from: ' + candidate);
      this.lastCandidateEl.textContent = candidate;
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, 'text/xml');

      const { items, idsInFeed } = this.parseFeedXml(xml);

      // diff existing
      const newIds = idsInFeed.filter(id => !this.feedMap.has(id));
      const removedIds = Array.from(this.feedMap.keys()).filter(id => !idsInFeed.includes(id));
      this.logMessage(`Parsed ${items.length} items (new:${newIds.length} removed:${removedIds.length})`);

      // remove deleted items from DOM & storage
      removedIds.forEach(id => {
        this.feedMap.delete(id);
        this.removeItemFromDOM(id);
        this.knownItems.delete(id);
      });
      this.saveKnownItems();

      // add or merge items
      const newlyAdded = [];
      for (const it of items) {
        const prev = this.feedMap.get(it.id);
        if (!prev) {
          this.feedMap.set(it.id, it);
          newlyAdded.push(it);
        } else {
          // merge carefully to preserve liveStreamingDetails/translation/community if not replaced
          const merged = Object.assign({}, prev, it);
          merged.liveStreamingDetails = (it.liveStreamingDetails !== null && it.liveStreamingDetails !== undefined) ? it.liveStreamingDetails : (prev.liveStreamingDetails || null);
          merged.translatedTitle = prev.translatedTitle || it.translatedTitle || null;
          const itViews = it.community && it.community.views ? parseInt(it.community.views) : 0;
          merged.community = (!it.community || itViews === 0) ? (prev.community || it.community) : it.community;
          this.feedMap.set(it.id, merged);
          // update DOM only for meaningful changes
          const changed = (prev.title !== merged.title) || (prev.summary !== merged.summary) || (JSON.stringify(prev.liveStreamingDetails) !== JSON.stringify(merged.liveStreamingDetails)) || (prev.translatedTitle !== merged.translatedTitle);
          if (changed) this.updateItemInDOM(merged);
        }
      }

      // insert newly added into DOM
      if (newlyAdded.length > 0) {
        this.logMessage(`${newlyAdded.length} new items found.`);
        newlyAdded.forEach(it => { this.knownItems.add(it.id); this.insertItemToDOM(it, true); });
        this.saveKnownItems();

        // call YT API only for new ones (get accurate live details)
        const newVideoIds = newlyAdded.map(i => i.videoId).filter(Boolean);
        if (newVideoIds.length > 0) {
          await this.getLiveStatusForVideoIds(newVideoIds);
          // set next allowed YT API time (cooldown)
          this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
        }
        this.playDing();
      } else {
        this.logMessage('No new items this fetch.');
      }

      // if feed empty, schedule forced YT checks every 5min
      if (this.feedMap.size === 0) {
        this.logMessage('Feed empty ‚Äî scheduling forced YT status checks every 5 minutes.');
        this.scheduleForceStatusChecks();
      } else {
        this.clearForceStatusChecks();
      }

      // update UI stats
      this.updateTotals();
      this.setStatus('Connected', 'connected');
      this.updateLastUpdateTime();
      this.applyFilter(); // apply current filter to updated DOM

      // if translation is enabled and there are untranslated titles, start translating
      if (this.isTranslationEnabled) {
        await this.translateAllTitles();
      }
    } catch (err) {
      console.error('fetchFeed error', err);
      this.logMessage('Feed fetch error: ' + (err && err.message ? err.message : err));
      this.setStatus('Error', 'error');
      this.showError('Failed to load RSS feed: ' + (err && err.message ? err.message : 'Unknown error'));
    }
  }

  parseFeedXml(xmlDoc) {
    const entries = Array.from(xmlDoc.querySelectorAll('entry'));
    const items = [];
    const idsInFeed = [];
    for (const entry of entries) {
      const id = entry.querySelector('id')?.textContent || '';
      if (!id) continue;
      if (idsInFeed.includes(id)) continue;
      idsInFeed.push(id);

      const originalTitle = entry.querySelector('title')?.textContent || 'No title';
      const link = entry.querySelector('link')?.getAttribute('href') || '#';
      const published = entry.querySelector('published')?.textContent || '';
      const updated = entry.querySelector('updated')?.textContent || '';

      const mediaGroup = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'group')[0];
      let summary = entry.querySelector('summary')?.textContent || 'No description available';
      if (mediaGroup) {
        const desc = mediaGroup.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'description')[0];
        if (desc && desc.textContent.trim() !== '') summary = desc.textContent;
      }

      const community = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'community')[0];
      const starRating = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'starRating')[0]?.getAttribute('average') || '0.00';
      const ratingCount = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'starRating')[0]?.getAttribute('count') || '0';
      const views = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'statistics')[0]?.getAttribute('views') || '0';

      const videoId = this.extractVideoId(link);
      const thumbnail = videoId ? `https://i2.ytimg.com/vi/${videoId}/hqdefault.jpg` : null;
      const isNew = !this.knownItems.has(id);
      const hasStats = parseInt(views) > 0;

      items.push({
        id,
        title: originalTitle,
        originalTitle,
        translatedTitle: null,
        link,
        published: this.parseDateTime(published),
        updated: this.parseDateTime(updated),
        summary: this.cleanSummary(summary),
        thumbnail,
        community: { starRating, ratingCount, views },
        isNew,
        hasStats,
        videoId,
        liveStreamingDetails: null
      });
    }

    // sort newest first
    items.sort((a, b) => new Date(b.published.full) - new Date(a.published.full));
    return { items, idsInFeed };
  }

  /* ---------- YouTube API (only when needed) ---------- */
  async getLiveStatusForVideoIds(videoIdList = []) {
    if (!this.YT_API_KEY || this.YT_API_KEY === 'YOUR_YOUTUBE_API_KEY_HERE') {
      this.logMessage('YouTube API key not configured ‚Äî skipping live status checks.');
      return;
    }
    if (!videoIdList || videoIdList.length === 0) {
      this.logMessage('No video IDs provided for YT API call.');
      return;
    }

    const chunks = [];
    for (let i = 0; i < videoIdList.length; i += 50) chunks.push(videoIdList.slice(i, i + 50));

    try {
      for (const chunk of chunks) {
        const parts = 'id,liveStreamingDetails';
        const url = `https://www.googleapis.com/youtube/v3/videos?part=${parts}&id=${chunk.join(',')}&key=${this.YT_API_KEY}`;
        this.logMessage(`Calling YouTube API for ${chunk.length} videos...`);
        const res = await fetch(url);
        if (!res.ok) {
          this.logMessage(`YouTube API returned ${res.status}`);
          continue;
        }
        const data = await res.json();
        if (!data.items) continue;
        for (const obj of data.items) {
          const vid = obj.id;
          const liveDetails = obj.liveStreamingDetails || null;
          for (const [id, item] of this.feedMap.entries()) {
            if (item.videoId === vid) {
              item.liveStreamingDetails = liveDetails;
              this.feedMap.set(id, item);
              this.logMessage(`Merged live details for ${vid}`);
              this.updateItemInDOM(item);
            }
          }
        }
      }
      // update cooldown timer for YT API (5 minutes)
      this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
    } catch (err) {
      console.error('YT API error', err);
      this.logMessage('YT API error: ' + (err && err.message ? err.message : err));
    }
  }

  scheduleForceStatusChecks() {
    if (this.forceStatusTimer) return;
    this.forceStatusTimer = setInterval(async () => {
      this.logMessage('Forced YT status check (feed empty).');
      const knownVideoIds = Array.from(this.feedMap.values()).map(i => i.videoId).filter(Boolean);
      if (knownVideoIds.length > 0) await this.getLiveStatusForVideoIds(knownVideoIds);
      else this.logMessage('No known video ids to check.');
    }, this.forceStatusIntervalMs);
  }
  clearForceStatusChecks() {
    if (this.forceStatusTimer) {
      clearInterval(this.forceStatusTimer);
      this.forceStatusTimer = null;
      this.logMessage('Cleared forced YT checks.');
    }
  }

  /* ---------- DOM insertion / update / remove (incremental, no full refresh) ---------- */
  getOrCreateList() {
    if (!this.feedListEl) this.feedListEl = document.getElementById('feedList');
    return this.feedListEl;
  }

  makeItemHtml(item) {
    const displayTitle = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
    let dateDisplay = '';
    let communityHtml = '';
    let postClass = item.isNew ? ' new' : '';
    let copyDate = item.published?.date || '';
    let copyTime = item.published?.time || '';

    if (item.liveStreamingDetails) {
      const l = item.liveStreamingDetails;
      if (l.actualStartTime && !l.actualEndTime) {
        dateDisplay = 'üî¥ Live Now';
        communityHtml = `<div class="meta">üìà Community Stats: Live stream in progress!</div>`;
        postClass += ' no-stats-post';
      } else if (l.scheduledStartTime && !l.actualStartTime) {
        const sched = this.parseDateTime(l.scheduledStartTime);
        dateDisplay = `‚è∞ Scheduled: ${sched.date} ${sched.time}`;
        copyDate = sched.date; copyTime = sched.time;
        postClass += ' no-stats-post';
      } else if (l.actualStartTime) {
        const started = this.parseDateTime(l.actualStartTime);
        dateDisplay = `üìÖ Published: ${started.date} ${started.time}`;
        copyDate = started.date; copyTime = started.time;
        if (item.updated) dateDisplay += ` | üîÑ Updated: ${item.updated.date} ${item.updated.time}`;
        const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views || 0);
        const starRating = '‚≠ê'.repeat(Math.round(parseFloat(item.community.starRating || 0)));
        communityHtml = `<div class="meta">üìà ${starRating} (${item.community.starRating} avg from ${item.community.ratingCount}) ‚Ä¢ üëÄ ${formattedViews}</div>`;
      }
    } else {
      dateDisplay = `üìÖ Published: ${item.published?.date || 'Unknown'} ${item.published?.time || ''}`;
      if (item.updated) dateDisplay += ` | üîÑ Updated: ${item.updated.date} ${item.updated.time}`;
      if (item.hasStats) {
        const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views || 0);
        const starRating = '‚≠ê'.repeat(Math.round(parseFloat(item.community.starRating || 0)));
        communityHtml = `<div class="meta">üìà ${starRating} (${item.community.starRating} avg) ‚Ä¢ üëÄ ${formattedViews}</div>`;
      } else {
        communityHtml = `<div class="meta">üìà Community Stats: Not yet available</div>`;
        postClass += ' no-stats-post';
      }
    }

    const descriptionHtml = item.hasStats ? `<div class="desc">${this.escapeHtml(item.summary)}</div>` : '';
    const thumbHtml = item.thumbnail ? `<div class="thumb" data-video-id="${this.escapeHtml(item.videoId || '')}" data-item-id="${this.escapeHtml(item.id)}"><img src="${this.escapeHtml(item.thumbnail)}" alt="${this.escapeHtml(displayTitle)}"><div class="play"></div></div>` : '';

    // Note: using data-item-id for copy button to find item
    return `
      <div class="feed-item ${postClass}" data-item-id="${this.escapeHtml(item.id)}" data-video-id="${this.escapeHtml(item.videoId || '')}">
        ${thumbHtml}
        <div class="content">
          <div class="title-line">${this.escapeHtml(displayTitle)}</div>
          <div class="meta">${dateDisplay}</div>
          ${descriptionHtml}
          ${communityHtml}
          <div class="actions" style="margin-top:10px">
            <a class="btn watch" href="${this.escapeHtml(item.link)}" target="_blank" onclick="event.stopPropagation()">üé¨ Watch</a>
            <button class="btn copy" data-item-id="${this.escapeHtml(item.id)}">üìã Copy Info</button>
          </div>
        </div>
      </div>
    `;
  }

  insertItemToDOM(item, prepend = false) {
    const wrapper = document.createElement('div');
    wrapper.innerHTML = this.makeItemHtml(item);
    const node = wrapper.firstElementChild;
    if (!node) return;
    const list = this.getOrCreateList();
    // remove loading box if present
    if (this.loadingBox) { this.loadingBox.remove(); this.loadingBox = null; }
    if (prepend) list.insertBefore(node, list.firstChild);
    else list.appendChild(node);

    // attach handlers
    this.attachHandlers(node);
  }

  updateItemInDOM(item) {
    const sel = `.feed-item[data-item-id="${this.escapeCssSelector(item.id)}"]`;
    const existing = document.querySelector(sel);
    if (!existing) { this.insertItemToDOM(item, true); return; }
    const wrapper = document.createElement('div');
    wrapper.innerHTML = this.makeItemHtml(item);
    const newNode = wrapper.firstElementChild;
    existing.replaceWith(newNode);
    this.attachHandlers(newNode);
  }

  removeItemFromDOM(id) {
    const node = document.querySelector(`.feed-item[data-item-id="${this.escapeCssSelector(id)}"]`);
    if (node) node.remove();
  }

  attachHandlers(root) {
    // thumbnail click -> embed iframe
    const thumb = root.querySelector('.thumb');
    if (thumb) {
      thumb.addEventListener('click', (ev) => {
        const vid = thumb.dataset.videoId;
        if (vid) {
          const iframe = this.createIframeWrapper(vid);
          thumb.replaceWith(iframe);
        }
        ev.stopPropagation();
      });
    }
    // copy button
    const copyBtn = root.querySelector('.btn.copy');
    if (copyBtn) {
      copyBtn.addEventListener('click', (e) => {
        const id = copyBtn.getAttribute('data-item-id');
        this.copyToClipboardById(id);
      });
    }
  }

  createIframeWrapper(videoId) {
    const wrapper = document.createElement('div');
    wrapper.className = 'thumb iframe';
    wrapper.style.minWidth = '200px';
    wrapper.style.height = '112px';
    const iframe = document.createElement('iframe');
    iframe.width = "200"; iframe.height = "112";
    iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
    iframe.frameBorder = "0";
    iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
    iframe.allowFullscreen = true;
    wrapper.appendChild(iframe);
    return wrapper;
  }

  /* ---------- copy behavior (special for Live Now) ---------- */
  copyToClipboardById(id) {
    const item = this.feedMap.get(id);
    if (!item) return;
    const title = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
    const isLiveNow = item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime;
    // choose time: if live actualStartTime exists, use that; otherwise published
    let date = item.published?.date || '';
    let time = item.published?.time || '';
    if (item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime) {
      const dt = this.parseDateTime(item.liveStreamingDetails.actualStartTime);
      date = dt.date; time = dt.time;
    }
    let text;
    if (isLiveNow) {
      // EXACT format requested
      text = `Title: ${title}\nüî¥ Live Now\n\nDate: ${date} ${time}\nURL: ${item.link}`;
    } else {
      text = `Title: ${title}\n\nDate: ${date} ${time}\nURL: ${item.link}`;
    }
    this.copyRawText(text);
    this.showMessage('Video info copied to clipboard!');
  }
  copyRawText(s) {
    const ta = document.createElement('textarea');
    ta.value = s;
    document.body.appendChild(ta);
    ta.select();
    try { document.execCommand('copy'); } catch (e) { this.logMessage('Copy failed: ' + e.message); }
    ta.remove();
  }

  showMessage(text) {
    // quick ephemeral modal-like message using debug log style
    this.logMessage('UI: ' + text);
    // also use small on-screen message
    const prev = document.getElementById('flashMsg'); if (prev) prev.remove();
    const el = document.createElement('div'); el.id = 'flashMsg';
    el.style.position = 'fixed'; el.style.right = '18px'; el.style.bottom = '18px';
    el.style.background = 'linear-gradient(90deg,#7C6CFA,#6EE7B7)'; el.style.color = '#021018';
    el.style.padding = '10px 14px'; el.style.borderRadius = '10px'; el.style.fontWeight = '800';
    el.textContent = text;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 1800);
  }

  /* ---------- utility helpers ---------- */
  extractVideoId(url) {
    if (!url) return null;
    const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
    const m = url.match(regex);
    return m ? m[1] : null;
  }
  parseDateTime(dateString) {
    if (!dateString) return { date: '', time: '', full: null };
    const d = new Date(dateString);
    // enforce Asia/Kolkata display
    const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true, timeZone: 'Asia/Kolkata' };
    const fmt = new Intl.DateTimeFormat('en-GB', options);
    const parts = fmt.formatToParts(d);
    const dateFormatted = `${parts.find(p => p.type === 'day').value}-${parts.find(p => p.type === 'month').value}-${parts.find(p => p.type === 'year').value}`;
    const timeFormatted = `${parts.find(p => p.type === 'hour').value}:${parts.find(p => p.type === 'minute').value}:${parts.find(p => p.type === 'second').value} ${parts.find(p => p.type === 'dayPeriod').value}`;
    return { date: dateFormatted, time: timeFormatted, full: d.toString() };
  }
  cleanSummary(s) { if (!s) return ''; const r = s.replace(/<[^>]*>/g, '').trim(); return r.length > 200 ? r.substring(0, 200) + '...' : r; }
  escapeHtml(t) { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; }
  escapeCssSelector(s) { if (window.CSS && CSS.escape) return CSS.escape(s); return String(s).replace(/(["\\])/g, '\\$1'); }
  jsEscape(s) { if (!s) return ''; return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, ''); }

  /* ---------- translate titles (ml -> en) with progress UI ---------- */
  async translateTitle(text) {
    if (!text || text.trim() === '') return 'No title';
    // quick ascii check skip
    if (/^[\x00-\x7F]+$/.test(text)) return text;
    try {
      const resp = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=ml&tl=en&dt=t&q=${encodeURIComponent(text)}`);
      if (!resp.ok) throw new Error('Translate API ' + resp.status);
      const data = await resp.json();
      const translated = data?.[0]?.[0]?.[0] || text;
      return translated;
    } catch (err) {
      this.logMessage('Translation failed: ' + (err && err.message ? err.message : err));
      return text;
    }
  }

  async translateAllTitles() {
    if (this.translationInProgress) return;
    const items = Array.from(this.feedMap.values()).filter(it => !it.translatedTitle);
    if (items.length === 0) {
      this.logMessage('No titles to translate.');
      return;
    }
    this.translationInProgress = true;
    this.translationProgressBox.style.display = '';
    const total = items.length;
    this.translationCountEl.textContent = `0/${total}`;
    this.translationFillEl.style.width = '0%';
    let done = 0;
    for (const item of items) {
      if (!this.isTranslationEnabled) { this.logMessage('Translation cancelled by user'); break; }
      try {
        const translated = await this.translateTitle(item.originalTitle);
        item.translatedTitle = translated;
        this.feedMap.set(item.id, item);
        this.updateItemInDOM(item);
      } catch (err) {
        this.logMessage('Translate error for item: ' + (err && err.message ? err.message : err));
      }
      done++;
      this.translationCountEl.textContent = `${done}/${total}`;
      this.translationFillEl.style.width = `${Math.round((done / total) * 100)}%`;
    }
    // hide after short delay
    setTimeout(() => { this.translationProgressBox.style.display = 'none'; }, 600);
    this.translationInProgress = false;
    this.logMessage('Translation pass finished/stopped.');
  }

  /* ---------- play ding (WebAudio) ---------- */
  playDing() {
    if (this.audioCtx) {
      try {
        const ctx = this.audioCtx;
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(880, ctx.currentTime);
        g.gain.setValueAtTime(0, ctx.currentTime);
        o.connect(g);
        g.connect(ctx.destination);
        // small envelope
        g.gain.linearRampToValueAtTime(0.22, ctx.currentTime + 0.01);
        o.frequency.exponentialRampToValueAtTime(1320, ctx.currentTime + 0.12);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.9);
        o.start(ctx.currentTime);
        o.stop(ctx.currentTime + 0.95);
        this.logMessage('Playing: ding (WebAudio)');
      } catch (e) {
        this.logMessage('WebAudio play failed: ' + e.message);
      }
    } else {
      // fallback: short beep using <audio> element if available in page (none included)
      this.logMessage('No WebAudio available for ding.');
    }
  }

  /* ---------- totals, status ---------- */
  updateTotals() {
    const total = this.feedMap.size;
    const released = Array.from(this.feedMap.values()).filter(item => !item.liveStreamingDetails || (item.liveStreamingDetails && item.liveStreamingDetails.actualEndTime)).length;
    const unreleased = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && !item.liveStreamingDetails.actualEndTime).length;
    document.querySelector('[data-filter="all"]').textContent = `All (${total})`;
    document.querySelector('[data-filter="released"]').textContent = `Released (${released})`;
    document.querySelector('[data-filter="unreleased"]').textContent = `Unreleased (${unreleased})`;
    this.totalPostsEl.textContent = total;
    // new posts count
    const newCount = Array.from(this.feedMap.values()).filter(i => i.isNew).length;
    this.newPostsEl.textContent = newCount;
  }
  setStatus(text, className) {
    this.statusTextEl.textContent = text;
    this.statusIndicatorEl.className = 'status-ind';
    if (className === 'loading') this.statusIndicatorEl.classList.add('loading');
    else if (className === 'connected') this.statusIndicatorEl.classList.add('connected');
    else if (className === 'error') this.statusIndicatorEl.classList.add('error');
  }
  updateLastUpdateTime() {
    const now = new Date();
    const opts = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' };
    this.lastUpdateEl.textContent = now.toLocaleString('en-GB', opts);
  }
  showError(msg) {
    const list = this.getOrCreateList();
    if (!this.loadingBox) {
      const box = document.createElement('div');
      box.style.padding = '12px';
      box.style.borderRadius = '10px';
      box.style.background = 'linear-gradient(90deg, rgba(255,0,0,0.06), rgba(255,0,0,0.02))';
      box.style.color = '#ffdddd';
      box.textContent = msg;
      list.prepend(box);
    } else {
      this.loadingBox.textContent = msg;
    }
  }

  /* ---------- rendering helpers ---------- */
  renderAllItems() {
    // re-render entire list (used when toggling translation off)
    const list = this.getOrCreateList();
    list.innerHTML = '';
    for (const item of Array.from(this.feedMap.values()).sort((a,b)=> new Date(b.published.full) - new Date(a.published.full))) {
      list.appendChild(this.createNodeFromHtml(this.makeItemHtml(item)));
    }
    this.updateTotals();
  }
  createNodeFromHtml(html) {
    const wrapper = document.createElement('div'); wrapper.innerHTML = html; return wrapper.firstElementChild;
  }

  /* ---------- filter ---------- */
  applyFilter() {
    const active = document.querySelector('.filter-btn.active')?.dataset.filter || 'all';
    for (const node of document.querySelectorAll('.feed-item')) {
      const vid = node.dataset.videoId;
      const id = node.dataset.itemId;
      const item = this.feedMap.get(id);
      if (!item) continue;
      let show = true;
      if (active === 'released') show = !item.liveStreamingDetails || (item.liveStreamingDetails && item.liveStreamingDetails.actualEndTime);
      else if (active === 'unreleased') show = item.liveStreamingDetails && !item.liveStreamingDetails.actualEndTime;
      node.style.display = show ? '' : 'none';
    }
  }

  /* ---------- helper for insertion (used after parse) ---------- */
  insertItemToDOMSorted(item) {
    // insert maintaining chronological order: newest first
    const list = this.getOrCreateList();
    const nodes = Array.from(list.querySelectorAll('.feed-item'));
    // find first node whose published.full is older than item
    const itemDate = new Date(item.published.full);
    let inserted = false;
    for (const n of nodes) {
      const id = n.dataset.itemId;
      const other = this.feedMap.get(id);
      if (other) {
        const otherDate = new Date(other.published.full);
        if (otherDate < itemDate) {
          list.insertBefore(this.createNodeFromHtml(this.makeItemHtml(item)), n);
          inserted = true;
          break;
        }
      }
    }
    if (!inserted) list.appendChild(this.createNodeFromHtml(this.makeItemHtml(item)));
  }

  /* ---------- convenience: create node & attach handlers ---------- */
  createNodeAndAttach(item) {
    const node = this.createNodeFromHtml(this.makeItemHtml(item));
    this.attachHandlers(node);
    return node;
  }

  /* ---------- small helpers ---------- */
  updateItemInDOM_or_insert(item) {
    const sel = `.feed-item[data-item-id="${this.escapeCssSelector(item.id)}"]`;
    const existing = document.querySelector(sel);
    if (existing) {
      const newNode = this.createNodeAndAttach(item);
      existing.replaceWith(newNode);
    } else {
      // insert at top
      const list = this.getOrCreateList();
      const node = this.createNodeAndAttach(item);
      list.insertBefore(node, list.firstChild);
    }
  }

  getOrCreateList() {
    if (!this.feedListEl) this.feedListEl = document.getElementById('feedList');
    return this.feedListEl;
  }

  createNodeFromHtmlAndAttach(html) {
    const node = this.createNodeFromHtml(html);
    this.attachHandlers(node);
    return node;
  }
}

/* ===========================
   Boot the RSSFeedReader with logic glue
   =========================== */

(function boot() {
  const app = new RSSFeedReader({
    feedBase: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCbg8V1kty3s1kcCch2VHwEw',
    YT_API_KEY: 'AIzaSyAzDe7gqM5P_cGwxreEVtzAbrk-5BubrcM', // replace with your key to enable accurate live details
    pollIntervalMs: 60000,
    forceStatusIntervalMs: 5 * 60 * 1000
  });

  // wire incremental insertion separately (because class was created earlier and some methods above are used internally)
  // We need some small adapter methods that call the class instance methods above.
  // But to keep things simple and readable, use the app instance directly for operations below.

  // Expose app globally for console debugging
  window.app = app;

  // Ensure debug timers update and never show --:--
  function tickDebugTimers() {
    // feed timer
    const now = Date.now();
    app.feedTimerEl.textContent = app.msToMMSS(Math.max(0, app.nextFeedFetchAt - now));
    // next YT
    app.ytTimerEl.textContent = app.msToMMSS(Math.max(0, app.nextYTApiAt - now));
  }
  setInterval(tickDebugTimers, 1000);

  // When feed items are inserted / updated, we need functions on app instance
  // but those methods are already defined as instance methods above.

  // Small safety: if app.fetchInterval fails for any reason, show error in debug console
  window.addEventListener('error', (e) => {
    app.logMessage('Global error: ' + (e && e.message ? e.message : e));
  });

  // End boot
})();
</script>
</body>
</html>
