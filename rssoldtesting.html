<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Prayer RSS Feed</title>
    <style>
        /* ---------- Enhanced Futuristic Theme ---------- */
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #111127;
            --bg-tertiary: #1a1a2e;
            --card-bg: rgba(255, 255, 255, 0.03);
            --glass-light: rgba(255, 255, 255, 0.08);
            --glass-medium: rgba(255, 255, 255, 0.05);
            --accent-primary: #00ff88;
            --accent-secondary: #8b5cf6;
            --accent-tertiary: #06b6d4;
            --text-primary: #ffffff;
            --text-secondary: #a8b2d1;
            --text-muted: #6b7280;
            --danger: #ef4444;
            --warning: #f59e0b;
            --success: #10b981;
            --no-stats-bg: rgba(239, 68, 68, 0.1);
            --border-subtle: rgba(255, 255, 255, 0.1);
            --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.8);
            --shadow-xl: 0 35px 70px -15px rgba(0, 0, 0, 0.9);
        }

        /* Base Styles */
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: radial-gradient(circle at 20% 20%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 80% 80%, rgba(6, 182, 212, 0.15) 0%, transparent 50%),
            radial-gradient(circle at 40% 40%, rgba(0, 255, 136, 0.08) 0%, transparent 50%),
            linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-tertiary) 100%);
            color: var(--text-primary);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow-x: hidden;
        }

        .wrap {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            min-height: 100vh;
        }

        /* Header Styles */
        header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 2rem;
            position: relative;
        }

        .title {
            display: flex;
            flex-direction: column;
            position: relative;
        }

        h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 50%, var(--accent-tertiary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.025em;
            position: relative;
        }

        h1::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 50%, var(--accent-tertiary) 100%);
            filter: blur(20px);
            opacity: 0.3;
            z-index: -1;
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                opacity: 0.2;
                transform: scale(0.95);
            }
            to {
                opacity: 0.4;
                transform: scale(1.05);
            }
        }

        p.sub {
            margin: 0.5rem 0 0 0;
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
            opacity: 0.8;
        }

        /* Channel Selector */
        .channel-selector {
            position: relative;
            margin-top: 1rem;
            margin-right: auto;
            min-width: 250px;
        }

        .channel-selector select {
            width: 100%;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            border-radius: 0.5rem;
            background-color: var(--glass-light);
            border: 1px solid var(--border-subtle);
            color: var(--text-primary);
            appearance: none;
            cursor: pointer;
            outline: none;
        }
        
        .channel-selector select option {
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .channel-selector select:focus {
            outline: 2px solid var(--accent-primary);
        }

        .channel-selector::after {
            content: '▼';
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        /* Status Card */
        .status-card {
            margin-top: 2rem;
            padding: 1.5rem;
            border-radius: 1.5rem;
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--glass-medium) 100%), var(--card-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            box-shadow: var(--shadow-lg);
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
            position: relative;
            overflow: hidden;
        }

        .status-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        .status-item {
            background: var(--glass-medium);
            padding: 0.75rem 1rem;
            border-radius: 2rem;
            color: var(--text-secondary);
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .status-item:hover {
            background: var(--glass-light);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .status-ind {
            width: 0.75rem;
            height: 0.75rem;
            border-radius: 50%;
            background: var(--text-muted);
            position: relative;
        }

        .status-ind.loading {
            background: var(--warning);
            animation: pulse 2s infinite;
        }

        .status-ind.loading::after {
            content: '';
            position: absolute;
            inset: -4px;
            border: 2px solid var(--warning);
            border-radius: 50%;
            animation: ripple 2s infinite;
        }

        .status-ind.connected {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
        }

        .status-ind.error {
            background: var(--danger);
            animation: shake 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.1);
            }
        }

        @keyframes ripple {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(1.8);
            }
        }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }
            25% {
                transform: translateX(-2px);
            }
            75% {
                transform: translateX(2px);
            }
        }

        /* Filter Buttons */
        .filters {
            margin-top: 1.5rem;
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .filter-btn {
            border-radius: 2rem;
            padding: 0.75rem 1.5rem;
            border: 1px solid var(--border-subtle);
            background: var(--card-bg);
            color: var(--text-secondary);
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .filter-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .filter-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .filter-btn.active {
    background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    color: var(--bg-primary); /* Ensuring text is visible */
    border-color: transparent;
    box-shadow: 0 8px 25px rgba(0, 255, 136, 0.3);
    transform: translateY(-3px);
}

        .filter-btn.active::before {
            opacity: 0;
        }

        /* Feed Container */
        .feed-container {
            margin-top: 2rem;
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--glass-medium) 100%), var(--card-bg);
            padding: 2rem;
            border-radius: 1.5rem;
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            position: relative;
            overflow: hidden;
        }

        .feed-container::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, var(--accent-primary), transparent, var(--accent-secondary), transparent);
            animation: rotate 20s linear infinite;
            opacity: 0.05;
        }

        @keyframes rotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        .feed-list {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            position: relative;
            z-index: 1;
        }

        /* Feed Items */
        .feed-item {
            display: flex;
            gap: 1.5rem;
            align-items: flex-start;
            padding: 1.5rem;
            border-radius: 1rem;
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--card-bg) 100%);
            border-left: 4px solid var(--accent-secondary);
            backdrop-filter: blur(15px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .feed-item::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .feed-item:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-xl), 0 0 40px rgba(0, 255, 136, 0.2);
            border-left-color: var(--accent-primary);
        }

        .feed-item:hover::before {
            opacity: 0.03;
        }

        .feed-item.no-stats-post {
            background: linear-gradient(135deg, var(--no-stats-bg), rgba(239, 68, 68, 0.05));
            border-left-color: var(--danger);
        }

        .feed-item.new {
            animation: slideInUp 0.6s ease-out;
            border-left-color: var(--accent-primary);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(30px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .new-badge {
            position: absolute;
            top: -12px;
            right: -12px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            font-weight: 800;
            padding: 18px 12px 6px 18px;
            transform: rotate(45deg);
            font-size: 0.8rem;
            transform-origin: 100% 100%;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* Thumbnail */
        .thumb {
            width: 280px;
            height: 158px;
            border-radius: 0.75rem;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
            background: linear-gradient(135deg, var(--glass-medium), var(--card-bg));
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .thumb:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4);
        }

        .thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: all 0.3s ease;
        }

        .thumb:hover img {
            transform: scale(1.1);
        }

        .play {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .thumb:hover .play {
            opacity: 1;
        }

        .play::after {
            content: '';
            border-style: solid;
            border-width: 20px 0 20px 30px;
            border-color: transparent transparent transparent rgba(255, 255, 255, 0.9);
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        /* Content */
        .content {
            flex: 1;
            min-width: 0;
            position: relative;
        }

        .title-line {
            font-weight: 700;
            font-size: 1.25rem;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            line-height: 1.3;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .meta {
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .desc {
            color: var(--text-muted);
            margin-bottom: 1.25rem;
            line-height: 1.6;
            font-size: 0.9rem;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .actions {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 2rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: inherit;
            filter: blur(10px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .btn:hover::before {
            opacity: 0.5;
        }

        .btn.watch {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        .btn.watch:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 255, 136, 0.4);
        }

        .btn.copy {
            background: transparent;
            border: 2px solid var(--border-subtle);
            color: var(--text-secondary);
            backdrop-filter: blur(10px);
        }

        .btn.copy:hover {
            background: var(--glass-medium);
            border-color: var(--accent-tertiary);
            color: var(--accent-tertiary);
            transform: translateY(-2px);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .modal .box {
            background: linear-gradient(135deg, var(--glass-light) 0%, var(--card-bg) 100%);
            backdrop-filter: blur(20px);
            padding: 2rem;
            border-radius: 1.5rem;
            width: 90%;
            max-width: 500px;
            color: var(--text-primary);
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--border-subtle);
            position: relative;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .close-x {
            position: absolute;
            right: 1.5rem;
            top: 1.5rem;
            cursor: pointer;
            color: var(--text-muted);
            font-size: 1.5rem;
            transition: all 0.3s ease;
            border: none;
            background: none;
        }

        .close-x:hover {
            color: var(--danger);
            transform: scale(1.1);
        }

        /* Debug Box */
        #debug {
            margin-top: 1.5rem;
            padding: 1.5rem;
            border-radius: 1rem;
            background: linear-gradient(135deg, var(--glass-medium), var(--card-bg));
            backdrop-filter: blur(15px);
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            color: var(--text-secondary);
            border: 1px solid var(--border-subtle);
        }

        .timers {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .timer-chip {
            background: var(--glass-medium);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Translation Progress */
        .progress-track {
            height: 0.5rem;
            background: var(--card-bg);
            border-radius: 2rem;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: progressShine 2s infinite;
        }

        @keyframes progressShine {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        /* Loading Animation */
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .wrap {
                padding: 1.5rem;
            }
            h1 {
                font-size: 2rem;
            }
            .thumb {
                width: 240px;
                height: 135px;
            }
        }

        @media (max-width: 768px) {
            .feed-item {
                flex-direction: column;
            }
            .thumb {
                width: 100%;
                height: 200px;
            }
            .status-card {
                flex-direction: column;
                align-items: stretch;
            }
            .status-item {
                justify-content: center;
            }
            h1 {
                font-size: 1.75rem;
            }
        }

        @media (max-width: 480px) {
            .wrap {
                padding: 1rem;
            }
            .feed-container {
                padding: 1rem;
            }
            .feed-item {
                padding: 1rem;
            }
            h1 {
                font-size: 1.5rem;
            }
        }
        
        .notification {
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
            padding: 1rem 2rem;
            border-radius: 1rem;
            box-shadow: var(--shadow-lg);
            z-index: 999;
            cursor: pointer;
            animation: fadeInRight 0.5s ease-out;
            font-weight: bold;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .notification.show {
            display: block;
            opacity: 1;
        }
        
        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
<div class="wrap">
    <header>
        <div class="title">
            <h1>Prayer Rss Feed</h1>
            <p class="sub">Realtime RSS viewer</p>
        </div>
        <div class="channel-selector">
            <label for="channelSelect" class="sr-only">Select Channel</label>
            <select id="channelSelect"></select>
        </div>
    </header>

    <div class="notification" id="newPostNotification"></div>

    <div class="status-card" role="status" aria-live="polite">
        <div class="status-item"><span id="statusIndicator" class="status-ind loading"></span> Status: <strong
                id="statusText" style="margin-left:6px">Loading...</strong></div>
        <div class="status-item">Last update: <strong id="lastUpdate" style="margin-left:6px">Never</strong></div>
        <div class="status-item">Total posts: <strong id="totalPosts" style="margin-left:6px">0</strong></div>
        <div class="status-item">New: <strong id="newPosts" style="margin-left:6px">0</strong></div>
        <button id="openSettings" class="status-item"
                style="cursor:pointer;background:linear-gradient(90deg,var(--accent-primary),var(--accent-secondary));color:var(--bg-primary);border:none">
            ⚙️ Settings
        </button>
        <div style="margin-left:auto;display:flex;gap:10px;align-items:center">
            <div style="color:var(--text-secondary);font-weight:600">Theme</div>
            <button id="themeToggle" class="status-item" style="cursor:pointer">🌙</button>
        </div>
    </div>
    <div class="filters">
        <button class="filter-btn active" data-filter="all">All (0)</button>
        <button class="filter-btn" data-filter="released">Released (0)</button>
        <button class="filter-btn" data-filter="scheduled">Scheduled (0)</button>
        <button class="filter-btn" data-filter="live">Live (0)</button>
    </div>
    <div class="feed-container" id="feedContainer">
        <div id="feedList" class="feed-list">
            <div style="padding:28px;text-align:center;color:var(--text-muted)" id="loadingBox">
                <div style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.04);border-top-color:var(--accent-primary);margin:0 auto 12px;animation:spin 1s linear infinite"></div>
                Loading RSS feed...
            </div>
        </div>
    </div>
    <div id="debug" aria-hidden="false">
        <div class="timers">
            <div class="timer-chip">Next feed check: <span id="feedTimer">--:--</span></div>
            <div class="timer-chip">Next YouTube API: <span id="ytTimer">--:--</span></div>
            <div class="timer-chip">Fetch candidate: <span id="lastCandidate" style="margin-left:6px">-</span></div>
        </div>
        <div id="debugLog"
             style="max-height:220px;overflow:auto;white-space:pre-wrap;font-size:12px;color:var(--text-muted)"></div>
    </div>
</div>
<div id="modal" class="modal" aria-hidden="true">
    <div class="box" role="dialog" aria-modal="true">
        <div style="display:flex;align-items:center;justify-content:space-between">
            <strong style="color:var(--accent-primary);font-size:1.25rem">Advanced Settings</strong>
            <button id="closeModal" class="close-x">✕</button>
        </div>

        <div class="row">
            <div style="font-weight:700">Debug Mode</div>
            <label><input type="checkbox" id="debugSwitch" checked> <span style="margin-left:8px;color:var(--text-secondary)">On</span></label>
        </div>

        <div class="row">
            <div style="font-weight:700">Translation (ml → en)</div>
            <label><input type="checkbox" id="translationSwitch"> <span style="margin-left:8px;color:var(--text-secondary)">Enable</span></label>
        </div>

        <div id="translationProgressBox" style="display:none;padding-top:8px">
            <div style="font-weight:700;color:var(--text-secondary)">Translating titles <span id="translationCount"
                                                                                               style="font-weight:900">0/0</span>
            </div>
            <div class="progress-track" style="margin-top:8px">
                <div id="translationFill" class="progress-fill"></div>
            </div>
        </div>
        <div style="text-align:right;margin-top:12px">
            <button id="closeModalBtn" class="btn copy">Close</button>
        </div>
    </div>
</div>
<script>
    /* ##############################
     -   Complete YouTube RSS Reader
     -   Save as HTML and open in browser
     -   Replace YT_API_KEY with your key if you want live details
     ############################## */
    class RSSFeedReader {
        constructor(config = {}) {
            // config
            this.channels = config.channels || [];
            this.currentChannelId = config.defaultChannelId || this.channels[0].id;
            this.YT_API_KEY = config.YT_API_KEY || 'AIzaSyAzDe7gqM5P_cGwxreEVtzAbrk-5BubrcM';
            this.pollIntervalMs = config.pollIntervalMs || 60000;
            this.forceStatusIntervalMs = config.forceStatusIntervalMs || 5 * 60 * 1000;

            // state
            this.knownItemsKeyPrefix = 'rss-known-items-v1-';
            this.feedMap = new Map();
            this.isDebugging = true;
            this.isTranslationEnabled = false;
            this.translationInProgress = false;
            this.allChannelData = new Map();

            // timers & next times
            this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;
            this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
            this.lastFetchedEtag = localStorage.getItem('rss-etag-' + this.currentChannelId) || '';
            this.lastFetchedModified = localStorage.getItem('rss-last-modified-' + this.currentChannelId) || '';

            // DOM refs
            this.feedListEl = document.getElementById('feedList');
            this.loadingBox = document.getElementById('loadingBox');
            this.debugLogEl = document.getElementById('debugLog');
            this.feedTimerEl = document.getElementById('feedTimer');
            this.ytTimerEl = document.getElementById('ytTimer');
            this.lastCandidateEl = document.getElementById('lastCandidate');
            this.statusTextEl = document.getElementById('statusText');
            this.statusIndicatorEl = document.getElementById('statusIndicator');
            this.lastUpdateEl = document.getElementById('lastUpdate');
            this.totalPostsEl = document.getElementById('totalPosts');
            this.newPostsEl = document.getElementById('newPosts');
            this.translationFillEl = document.getElementById('translationFill');
            this.translationCountEl = document.getElementById('translationCount');
            this.translationProgressBox = document.getElementById('translationProgressBox');
            this.channelSelectEl = document.getElementById('channelSelect');
            this.notificationEl = document.getElementById('newPostNotification');

            // audio: use WebAudio (no external URLs)
            this.audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;

            // timers
            this.fetchInterval = null;
            this.debugInterval = null;
            this.forceStatusTimer = null;

            // UI wiring
            this.setupUI();

            // start
            this.logMessage('App initializing...');
            this.loadChannelFeeds();
            this.fetchFeeds();
            this.fetchInterval = setInterval(() => this.fetchFeeds(), this.pollIntervalMs);
            this.debugInterval = setInterval(() => this.updateDebugTimers(), 1000);
        }

        /* ---------- storage ---------- */
        loadKnownItems(channelId) {
            try {
                const s = localStorage.getItem(this.knownItemsKeyPrefix + channelId);
                return s ? new Set(JSON.parse(s)) : new Set();
            } catch (e) {
                console.error('loadKnownItems', e);
                return new Set();
            }
        }

        saveKnownItems(channelId, knownItems) {
            localStorage.setItem(this.knownItemsKeyPrefix + channelId, JSON.stringify(Array.from(knownItems)));
        }

        /* ---------- UI wiring ---------- */
        setupUI() {
            // Channel selector
            this.channels.forEach(channel => {
                const option = document.createElement('option');
                option.value = channel.id;
                option.textContent = channel.name;
                this.channelSelectEl.appendChild(option);
            });
            this.channelSelectEl.value = this.currentChannelId;
            this.channelSelectEl.addEventListener('change', (e) => this.switchChannel(e.target.value));

            document.getElementById('openSettings').addEventListener('click', () => this.openModal());
            document.getElementById('closeModal').addEventListener('click', () => this.closeModal());
            document.getElementById('closeModalBtn').addEventListener('click', () => this.closeModal());

            document.getElementById('debugSwitch').addEventListener('change', (e) => {
                this.isDebugging = e.target.checked;
                this.debugLogEl.parentElement.style.display = this.isDebugging ? '' : 'none';
            });

            document.getElementById('translationSwitch').addEventListener('change', async (e) => {
                this.isTranslationEnabled = e.target.checked;
                this.logMessage('Translation toggled ' + (this.isTranslationEnabled ? 'ON' : 'OFF'));
                if (this.isTranslationEnabled) await this.translateAllTitles();
                else this.renderAllItems();
            });

            document.getElementById('themeToggle').addEventListener('click', () => {
                const root = document.documentElement;
                if (root.style.getPropertyValue('--accent-primary') === '#00ff88') {
                    root.style.setProperty('--accent-primary', '#8b5cf6');
                    root.style.setProperty('--accent-secondary', '#06b6d4');
                    root.style.setProperty('--accent-tertiary', '#00ff88');
                    document.getElementById('themeToggle').textContent = '☀️';
                } else {
                    root.style.setProperty('--accent-primary', '#00ff88');
                    root.style.setProperty('--accent-secondary', '#8b5cf6');
                    root.style.setProperty('--accent-tertiary', '#06b6d4');
                    document.getElementById('themeToggle').textContent = '🌙';
                }
            });

            document.querySelectorAll('.filter-btn').forEach(btn => btn.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.applyFilter();
            }));

            document.getElementById('debug').style.display = '';

            this.notificationEl.addEventListener('click', () => {
                const channelId = this.notificationEl.dataset.channelId;
                if (channelId) {
                    this.switchChannel(channelId);
                    this.hideNotification();
                }
            });
        }

        openModal() {
            document.getElementById('modal').style.display = 'flex';
        }

        closeModal() {
            document.getElementById('modal').style.display = 'none';
        }

        /* ---------- logging & debug ---------- */
        logMessage(msg) {
            if (!this.isDebugging) return;
            const ts = new Date().toLocaleTimeString('en-GB');
            this.debugLogEl.textContent += `[${ts}] ${msg}\n`;
            this.debugLogEl.scrollTop = this.debugLogEl.scrollHeight;
        }

        updateDebugTimers() {
            const now = Date.now();
            const feedLeft = Math.max(0, this.nextFeedFetchAt - now);
            this.feedTimerEl.textContent = this.msToMMSS(feedLeft);
            const ytLeft = Math.max(0, this.nextYTApiAt - now);
            this.ytTimerEl.textContent = this.msToMMSS(ytLeft);
        }

        msToMMSS(ms) {
            const s = Math.floor(ms / 1000);
            const m = Math.floor(s / 60);
            const sec = s % 60;
            return `${String(m).padStart(2, '0')}:${String(sec).padStart(2, '0')}`;
        }

        /* ---------- robust fetch with CORS fallbacks & ETag/Last-Modified caching ---------- */
        async tryFetchWithFallbacks(feedUrl, channelId) {
            let lastError = null;
            const headers = {};
            const etagKey = 'rss-etag-' + channelId;
            const lastModKey = 'rss-last-modified-' + channelId;
            const lastFetchedEtag = localStorage.getItem(etagKey) || '';
            const lastFetchedModified = localStorage.getItem(lastModKey) || '';

            if (lastFetchedEtag) headers['If-None-Match'] = lastFetchedEtag;
            if (lastFetchedModified) headers['If-Modified-Since'] = lastFetchedModified;

            const feedCandidates = [
                feedUrl,
                'https://cors.kawiesh.top/' + feedUrl,
                'https://corsproxy.io/?' + encodeURIComponent(feedUrl),
                'https://api.allorigins.win/raw?url=' + encodeURIComponent(feedUrl)
            ];

            for (const candidate of feedCandidates) {
                try {
                    this.logMessage(`Attempting fetch for ${channelId}: ${candidate}`);
                    this.lastCandidateEl.textContent = candidate;
                    const r = await fetch(candidate, {
                        cache: 'no-store',
                        headers: headers
                    });

                    if (r.status === 304) {
                        this.logMessage('Server responded with 304 Not Modified. Using cached version.');
                        return { text: null, candidate: 'Cached', isCached: true };
                    }

                    if (!r.ok) {
                        throw new Error('HTTP ' + r.status);
                    }

                    const text = await r.text();
                    if (!text || text.indexOf('<feed') === -1) {
                        this.logMessage('Response did not contain feed XML; skipping candidate.');
                        lastError = new Error('No feed XML in response');
                        continue;
                    }

                    // Save new headers
                    const etag = r.headers.get('ETag');
                    const lastModified = r.headers.get('Last-Modified');
                    if (etag) localStorage.setItem(etagKey, etag);
                    if (lastModified) localStorage.setItem(lastModKey, lastModified);

                    return { text, candidate, isCached: false };
                } catch (err) {
                    lastError = err;
                    this.logMessage(`Candidate for ${channelId} failed: ${err.message}`);
                }
            }
            throw lastError || new Error('All fetch attempts failed');
        }

        /* ---------- main feed fetch & processing ---------- */
        async fetchFeeds() {
            this.nextFeedFetchAt = Date.now() + this.pollIntervalMs;
            this.logMessage('Starting multi-channel feed fetch...');

            if (this.currentChannelId) {
                this.setStatus('Fetching...', 'loading');
            }

            for (const channel of this.channels) {
                try {
                    const { text: xmlText, isCached } = await this.tryFetchWithFallbacks(channel.feedUrl, channel.id);
                    let items = [];
                    let idsInFeed = [];
                    let newIds = [];
                    const knownItems = this.loadKnownItems(channel.id);
                    let itemsToProcess = [];

                    if (isCached) {
                        this.logMessage(`Channel ${channel.name} is up to date.`);
                        if (this.allChannelData.has(channel.id)) {
                           itemsToProcess = Array.from(this.allChannelData.get(channel.id).values());
                        }
                    } else {
                        const parser = new DOMParser();
                        const xml = parser.parseFromString(xmlText, 'text/xml');
                        const parsedData = this.parseFeedXml(xml, knownItems);
                        items = parsedData.items;
                        idsInFeed = parsedData.idsInFeed;
                        newIds = idsInFeed.filter(id => !knownItems.has(id));
                        itemsToProcess = items;
                    }

                    if (newIds.length > 0) {
                        this.logMessage(`${newIds.length} new items found for channel ${channel.name}.`);
                        this.playDing();
                        const newVideoIds = items.filter(it => newIds.includes(it.id)).map(i => i.videoId).filter(Boolean);
                        if (newVideoIds.length > 0) {
                            await this.getLiveStatusForVideoIds(newVideoIds, items);
                        }
                        this.updateKnownItems(items, knownItems, newIds, channel.id);
                        if (channel.id !== this.currentChannelId) {
                           this.showNotification(`New post from ${channel.name}!`, channel.id);
                        }
                    }

                    // A second pass to update all known videos with live status if they don't have it
                    if (itemsToProcess.length > 0) {
                        const videosWithoutLiveStatus = itemsToProcess
                            .filter(item => item.liveStreamingDetails === null)
                            .map(item => item.videoId)
                            .filter(Boolean);
                        if (videosWithoutLiveStatus.length > 0) {
                            await this.getLiveStatusForVideoIds(videosWithoutLiveStatus, itemsToProcess);
                        }
                    }

                    this.allChannelData.set(channel.id, new Map(itemsToProcess.map(item => [item.id, item])));

                    if (channel.id === this.currentChannelId) {
                       this.updateCurrentFeedFromAllChannelData();
                    }

                } catch (err) {
                    console.error(`fetchFeed for ${channel.name} error`, err);
                    this.logMessage(`Feed fetch error for ${channel.name}: ` + (err && err.message ? err.message : 'Unknown error'));
                    if (channel.id === this.currentChannelId) {
                        this.setStatus('Error', 'error');
                        this.showError(`Failed to load RSS feed for ${channel.name}: ` + (err && err.message ? err.message : 'Unknown error'));
                    }
                }
            }
            if (this.currentChannelId) {
                this.setStatus('Connected', 'connected');
                this.updateLastUpdateTime();
            }
        }
        
        updateCurrentFeedFromAllChannelData() {
            this.feedMap = this.allChannelData.get(this.currentChannelId) || new Map();
            this.renderAllItems();
            this.updateTotals();
            this.applyFilter();
            if (this.feedMap.size === 0) {
                this.logMessage('Feed empty — scheduling forced YT status checks every 5 minutes.');
                this.scheduleForceStatusChecks();
            } else {
                this.clearForceStatusChecks();
            }
            if (this.isTranslationEnabled) {
                this.translateAllTitles();
            }
        }

        updateKnownItems(items, knownItems, newIds, channelId) {
            newIds.forEach(id => {
                knownItems.add(id);
            });
            this.saveKnownItems(channelId, knownItems);
        }

        parseFeedXml(xmlDoc, knownItems) {
            const entries = Array.from(xmlDoc.querySelectorAll('entry'));
            const items = [];
            const idsInFeed = [];
            for (const entry of entries) {
                const id = entry.querySelector('id')?.textContent || '';
                if (!id) continue;
                if (idsInFeed.includes(id)) continue;
                idsInFeed.push(id);

                const originalTitle = entry.querySelector('title')?.textContent || 'No title';
                const link = entry.querySelector('link')?.getAttribute('href') || '#';
                const published = entry.querySelector('published')?.textContent || '';
                const updated = entry.querySelector('updated')?.textContent || '';

                const mediaGroup = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'group')[0];
                let summary = entry.querySelector('summary')?.textContent || 'No description available';
                if (mediaGroup) {
                    const desc = mediaGroup.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'description')[0];
                    if (desc && desc.textContent.trim() !== '') summary = desc.textContent;
                }

                const community = entry.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'community')[0];
                const starRating = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'starRating')[0]?.getAttribute('average') || '0.00';
                const ratingCount = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'starRating')[0]?.getAttribute('count') || '0';
                const views = community?.getElementsByTagNameNS('http://search.yahoo.com/mrss/', 'statistics')[0]?.getAttribute('views') || '0';

                const videoId = this.extractVideoId(link);
                const thumbnail = videoId ? `https://cors.kawiesh.top/https://i2.ytimg.com/vi/${videoId}/hqdefault.jpg` : null;
                const isNew = !knownItems.has(id);
                const hasStats = parseInt(views) > 0;

                items.push({
                    id,
                    title: originalTitle,
                    originalTitle,
                    translatedTitle: null,
                    link,
                    published: this.parseDateTime(published),
                    updated: this.parseDateTime(updated),
                    summary: this.cleanSummary(summary),
                    thumbnail,
                    community: { starRating, ratingCount, views },
                    isNew,
                    hasStats,
                    videoId,
                    liveStreamingDetails: null
                });
            }
            items.sort((a, b) => new Date(b.published.full) - new Date(a.published.full));
            return { items, idsInFeed };
        }

        /* ---------- YouTube API (only when needed) ---------- */
        async getLiveStatusForVideoIds(videoIdList = [], items) {
            if (!this.YT_API_KEY || this.YT_API_KEY === 'AIzaSyA7j_nUEdvaNeFpJx5tBj4-VzlOpKXTkCg') {
                this.logMessage('YouTube API key not configured — skipping live status checks.');
                return;
            }
            if (!videoIdList || videoIdList.length === 0) {
                this.logMessage('No video IDs provided for YT API call.');
                return;
            }

            const chunks = [];
            for (let i = 0; i < videoIdList.length; i += 50) chunks.push(videoIdList.slice(i, i + 50));

            try {
                for (const chunk of chunks) {
                    const parts = 'id,liveStreamingDetails';
                    const url = `https://www.googleapis.com/youtube/v3/videos?part=${parts}&id=${chunk.join(',')}&key=${this.YT_API_KEY}`;
                    this.logMessage(`Calling YouTube API for ${chunk.length} videos...`);
                    const res = await fetch(url);
                    if (!res.ok) {
                        this.logMessage(`YouTube API returned ${res.status}`);
                        continue;
                    }
                    const data = await res.json();
                    if (!data.items) continue;
                    for (const obj of data.items) {
                        const vid = obj.id;
                        const liveDetails = obj.liveStreamingDetails || null;
                        for (const item of items) {
                            if (item.videoId === vid) {
                                item.liveStreamingDetails = liveDetails;
                            }
                        }
                    }
                }
                this.nextYTApiAt = Date.now() + this.forceStatusIntervalMs;
            } catch (err) {
                console.error('YT API error', err);
                this.logMessage('YT API error: ' + (err && err.message ? err.message : err));
            }
        }

        scheduleForceStatusChecks() {
            if (this.forceStatusTimer) return;
            this.forceStatusTimer = setInterval(async () => {
                this.logMessage('Forced YT status check (feed empty).');
                const knownVideoIds = Array.from(this.feedMap.values()).map(i => i.videoId).filter(Boolean);
                if (knownVideoIds.length > 0) await this.getLiveStatusForVideoIds(knownVideoIds);
                else this.logMessage('No known video ids to check.');
            }, this.forceStatusIntervalMs);
        }

        clearForceStatusChecks() {
            if (this.forceStatusTimer) {
                clearInterval(this.forceStatusTimer);
                this.forceStatusTimer = null;
                this.logMessage('Cleared forced YT checks.');
            }
        }

        /* ---------- DOM insertion / update / remove (incremental, no full refresh) ---------- */
        getOrCreateList() {
            if (!this.feedListEl) this.feedListEl = document.getElementById('feedList');
            return this.feedListEl;
        }

        makeItemHtml(item) {
            const displayTitle = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;
            let dateDisplay = '';
            let communityHtml = '';
            let postClass = item.isNew ? ' new' : '';
            let copyDate = item.published?.date || '';
            let copyTime = item.published?.time || '';
            let copyType = 'Date';
            let newBadgeHtml = item.isNew ? `<div class="new-badge">NEW</div>` : '';

            // Improved logic to check for live and scheduled videos
            const isLive = item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime;
            const isScheduled = item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime;
            const isReleased = !item.liveStreamingDetails || (!item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.scheduledStartTime) || (item.liveStreamingDetails.actualEndTime);
            
            if (isLive) {
                dateDisplay = '🔴 Live Now';
                communityHtml = `<div class="meta">📈 Community Stats: Live stream in progress!</div>`;
                postClass += ' no-stats-post';
            } else if (isScheduled) {
                const sched = this.parseDateTime(item.liveStreamingDetails.scheduledStartTime);
                dateDisplay = `⏰ Scheduled: ${sched.date} ${sched.time}`;
                copyDate = sched.date;
                copyTime = sched.time;
                copyType = 'Scheduled';
                postClass += ' no-stats-post';
            } else if (isReleased) {
                dateDisplay = `📅 Published: ${item.published?.date || 'Unknown'} ${item.published?.time || ''}`;
                if (item.updated) dateDisplay += ` | 🔄 Updated: ${item.updated.date} ${item.updated.time}`;
                if (item.hasStats) {
                    const formattedViews = new Intl.NumberFormat('en-IN').format(item.community.views || 0);
                    const starRating = '⭐'.repeat(Math.round(parseFloat(item.community.starRating || 0)));
                    communityHtml = `<div class="meta">📈 ${starRating} (${item.community.starRating} avg) • 👀 ${formattedViews}</div>`;
                } else {
                    communityHtml = `<div class="meta">📈 Community Stats: Not yet available</div>`;
                    postClass += ' no-stats-post';
                }
            }


            const descriptionHtml = item.hasStats ? `<div class="desc">${this.escapeHtml(item.summary)}</div>` : '';
            const thumbHtml = item.thumbnail ? `<div class="thumb" data-video-id="${this.escapeHtml(item.videoId || '')}" data-item-id="${this.escapeHtml(item.id)}"><img src="${this.escapeHtml(item.thumbnail)}" alt="${this.escapeHtml(displayTitle)}"><div class="play"></div></div>` : '';

            return `
      <div class="feed-item ${postClass}" data-item-id="${this.escapeHtml(item.id)}" data-video-id="${this.escapeHtml(item.videoId || '')}" data-copy-type="${copyType}" data-copy-date="${copyDate}" data-copy-time="${copyTime}">
        ${newBadgeHtml}
        ${thumbHtml}
        <div class="content">
          <div class="title-line">${this.escapeHtml(displayTitle)}</div>
          <div class="meta">${dateDisplay}</div>
          ${descriptionHtml}
          ${communityHtml}
          <div class="actions" style="margin-top:10px">
            <a class="btn watch" href="${this.escapeHtml(item.link)}" target="_blank" onclick="event.stopPropagation()">🎬 Watch</a>
            <button class="btn copy" data-item-id="${this.escapeHtml(item.id)}">📋 Copy Info</button>
          </div>
        </div>
      </div>
    `;
        }

        insertItemToDOM(item, prepend = false) {
            const wrapper = document.createElement('div');
            wrapper.innerHTML = this.makeItemHtml(item);
            const node = wrapper.firstElementChild;
            if (!node) return;
            const list = this.getOrCreateList();
            if (this.loadingBox) {
                this.loadingBox.remove();
                this.loadingBox = null;
            }
            if (prepend) list.insertBefore(node, list.firstChild);
            else list.appendChild(node);
            this.attachHandlers(node);
        }

        updateItemInDOM(item) {
            const sel = `.feed-item[data-item-id="${this.escapeCssSelector(item.id)}"]`;
            const existing = document.querySelector(sel);
            if (!existing) {
                this.insertItemToDOM(item, true);
                return;
            }
            const wrapper = document.createElement('div');
            wrapper.innerHTML = this.makeItemHtml(item);
            const newNode = wrapper.firstElementChild;
            existing.replaceWith(newNode);
            this.attachHandlers(newNode);
        }

        removeItemFromDOM(id) {
            const node = document.querySelector(`.feed-item[data-item-id="${this.escapeCssSelector(id)}"]`);
            if (node) node.remove();
        }

        attachHandlers(root) {
            const thumb = root.querySelector('.thumb');
            if (thumb) {
                thumb.addEventListener('click', (ev) => {
                    const vid = thumb.dataset.videoId;
                    if (vid) {
                        const iframe = this.createIframeWrapper(vid);
                        thumb.replaceWith(iframe);
                    }
                    ev.stopPropagation();
                });
            }
            const copyBtn = root.querySelector('.btn.copy');
            if (copyBtn) {
                copyBtn.addEventListener('click', (e) => {
                    const id = copyBtn.getAttribute('data-item-id');
                    this.copyToClipboardById(id);
                });
            }
        }

        createIframeWrapper(videoId) {
            const wrapper = document.createElement('div');
            wrapper.className = 'thumb iframe';
            wrapper.style.minWidth = '280px';
            wrapper.style.height = '158px';
            const iframe = document.createElement('iframe');
            iframe.width = "280";
            iframe.height = "158";
            iframe.src = `https://www.youtube.com/embed/${videoId}?autoplay=1`;
            iframe.frameBorder = "0";
            iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
            iframe.allowFullscreen = true;
            wrapper.appendChild(iframe);
            return wrapper;
        }

        /* ---------- copy behavior (special for Live Now) ---------- */
        copyToClipboardById(id) {
            const item = this.feedMap.get(id);
            if (!item) return;
            const title = this.isTranslationEnabled && item.translatedTitle ? item.translatedTitle : item.originalTitle;

            let text;
            if (item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime) {
                const dt = this.parseDateTime(item.liveStreamingDetails.actualStartTime);
                text = `Title: ${title}\n🔴 Live Now\n\nDate: ${dt.date} ${dt.time}\nURL: ${item.link}`;
            } else if (item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime) {
                const dt = this.parseDateTime(item.liveStreamingDetails.scheduledStartTime);
                text = `Title: ${title}\n\n⏰ Scheduled: ${dt.date} ${dt.time}\nURL: ${item.link}`;
            } else {
                let date = item.published?.date || '';
                let time = item.published?.time || '';
                text = `Title: ${title}\n\nDate: ${date} ${time}\nURL: ${item.link}`;
            }

            this.copyRawText(text);
            this.showMessage('Video info copied to clipboard!');
        }

        copyRawText(s) {
            const ta = document.createElement('textarea');
            ta.value = s;
            document.body.appendChild(ta);
            ta.select();
            try {
                document.execCommand('copy');
            } catch (e) {
                this.logMessage('Copy failed: ' + e.message);
            }
            ta.remove();
        }

        showMessage(text) {
            this.logMessage('UI: ' + text);
            const prev = document.getElementById('flashMsg');
            if (prev) prev.remove();
            const el = document.createElement('div');
            el.id = 'flashMsg';
            el.style.position = 'fixed';
            el.style.right = '18px';
            el.style.bottom = '18px';
            el.style.background = 'linear-gradient(90deg,var(--accent-secondary),var(--accent-primary))';
            el.style.color = 'var(--bg-primary)';
            el.style.padding = '10px 14px';
            el.style.borderRadius = '10px';
            el.style.fontWeight = '800';
            el.textContent = text;
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 1800);
        }

        /* ---------- utility helpers ---------- */
        extractVideoId(url) {
            if (!url) return null;
            const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
            const m = url.match(regex);
            return m ? m[1] : null;
        }

        parseDateTime(dateString) {
            if (!dateString) return { date: '', time: '', full: null };
            const d = new Date(dateString);
            const options = { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true, timeZone: 'Asia/Kolkata' };
            const fmt = new Intl.DateTimeFormat('en-GB', options);
            const parts = fmt.formatToParts(d);
            const dateFormatted = `${parts.find(p => p.type === 'day').value}-${parts.find(p => p.type === 'month').value}-${parts.find(p => p.type === 'year').value}`;
            const timeFormatted = `${parts.find(p => p.type === 'hour').value}:${parts.find(p => p.type === 'minute').value}:${parts.find(p => p.type === 'second').value} ${parts.find(p => p.type === 'dayPeriod').value}`;
            return { date: dateFormatted, time: timeFormatted, full: d.toString() };
        }

        cleanSummary(s) {
            if (!s) return '';
            const r = s.replace(/<[^>]*>/g, '').trim();
            return r.length > 200 ? r.substring(0, 200) + '...' : r;
        }

        escapeHtml(t) {
            const d = document.createElement('div');
            d.textContent = t;
            return d.innerHTML;
        }

        escapeCssSelector(s) {
            if (window.CSS && CSS.escape) return CSS.escape(s);
            return String(s).replace(/(["\\])/g, '\\$1');
        }

        jsEscape(s) {
            if (!s) return '';
            return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/\n/g, '\\n').replace(/\r/g, '');
        }

        /* ---------- translate titles (ml -> en) with progress UI ---------- */
        async translateTitle(text) {
            if (!text || text.trim() === '') return 'No title';
            if (/^[\x00-\x7F]+$/.test(text)) return text;
            try {
                const resp = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=ml&tl=en&dt=t&q=${encodeURIComponent(text)}`);
                if (!resp.ok) throw new Error('Translate API ' + resp.status);
                const data = await resp.json();
                const translated = data?.[0]?.[0]?.[0] || text;
                return translated;
            } catch (err) {
                this.logMessage('Translation failed: ' + (err && err.message ? err.message : err));
                return text;
            }
        }

        async translateAllTitles() {
            if (this.translationInProgress) return;
            const items = Array.from(this.feedMap.values()).filter(it => !it.translatedTitle);
            if (items.length === 0) {
                this.logMessage('No titles to translate.');
                return;
            }
            this.translationInProgress = true;
            this.translationProgressBox.style.display = '';
            const total = items.length;
            this.translationCountEl.textContent = `0/${total}`;
            this.translationFillEl.style.width = '0%';
            let done = 0;
            for (const item of items) {
                if (!this.isTranslationEnabled) {
                    this.logMessage('Translation cancelled by user');
                    break;
                }
                try {
                    const translated = await this.translateTitle(item.originalTitle);
                    item.translatedTitle = translated;
                    this.feedMap.set(item.id, item);
                    this.updateItemInDOM(item);
                } catch (err) {
                    this.logMessage('Translate error for item: ' + (err && err.message ? err.message : err));
                }
                done++;
                this.translationCountEl.textContent = `${done}/${total}`;
                this.translationFillEl.style.width = `${Math.round((done / total) * 100)}%`;
            }
            setTimeout(() => {
                this.translationProgressBox.style.display = 'none';
            }, 600);
            this.translationInProgress = false;
            this.logMessage('Translation pass finished/stopped.');
        }

        /* ---------- play ding (WebAudio) ---------- */
        playDing() {
            if (this.audioCtx) {
                try {
                    const ctx = this.audioCtx;
                    const o = ctx.createOscillator();
                    const g = ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(880, ctx.currentTime);
                    g.gain.setValueAtTime(0, ctx.currentTime);
                    o.connect(g);
                    g.connect(ctx.destination);
                    g.gain.linearRampToValueAtTime(0.22, ctx.currentTime + 0.01);
                    o.frequency.exponentialRampToValueAtTime(1320, ctx.currentTime + 0.12);
                    g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.9);
                    o.start(ctx.currentTime);
                    o.stop(ctx.currentTime + 0.95);
                    this.logMessage('Playing: ding (WebAudio)');
                } catch (e) {
                    this.logMessage('WebAudio play failed: ' + e.message);
                }
            } else {
                this.logMessage('No WebAudio available for ding.');
            }
        }

        /* ---------- totals, status ---------- */
        updateTotals() {
            const total = this.feedMap.size;
            const released = Array.from(this.feedMap.values()).filter(item => !item.liveStreamingDetails || (item.liveStreamingDetails && (item.liveStreamingDetails.actualEndTime || (!item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.scheduledStartTime)))).length;
            const scheduled = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime).length;
            const live = Array.from(this.feedMap.values()).filter(item => item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime).length;
            document.querySelector('[data-filter="all"]').textContent = `All (${total})`;
            document.querySelector('[data-filter="released"]').textContent = `Released (${released})`;
            document.querySelector('[data-filter="scheduled"]').textContent = `Scheduled (${scheduled})`;
            document.querySelector('[data-filter="live"]').textContent = `Live (${live})`;
            this.totalPostsEl.textContent = total;
            const newCount = Array.from(this.feedMap.values()).filter(i => i.isNew).length;
            this.newPostsEl.textContent = newCount;
        }

        setStatus(text, className) {
            this.statusTextEl.textContent = text;
            this.statusIndicatorEl.className = 'status-ind';
            if (className === 'loading') this.statusIndicatorEl.classList.add('loading');
            else if (className === 'connected') this.statusIndicatorEl.classList.add('connected');
            else if (className === 'error') this.statusIndicatorEl.classList.add('error');
        }

        updateLastUpdateTime() {
            const now = new Date();
            const opts = { day: '2-digit', month: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit' };
            this.lastUpdateEl.textContent = now.toLocaleString('en-GB', opts);
        }

        showError(msg) {
            const list = this.getOrCreateList();
            if (!this.loadingBox) {
                const box = document.createElement('div');
                box.style.padding = '12px';
                box.style.borderRadius = '10px';
                box.style.background = 'linear-gradient(90deg, rgba(255,0,0,0.06), rgba(255,0,0,0.02))';
                box.style.color = '#ffdddd';
                box.textContent = msg;
                list.prepend(box);
            } else {
                this.loadingBox.textContent = msg;
            }
        }

        showNotification(message, channelId) {
            this.notificationEl.textContent = message;
            this.notificationEl.dataset.channelId = channelId;
            this.notificationEl.classList.add('show');
            setTimeout(() => {
                this.hideNotification();
            }, 5000);
        }

        hideNotification() {
            this.notificationEl.classList.remove('show');
            this.notificationEl.dataset.channelId = '';
        }

        /* ---------- rendering helpers ---------- */
        renderAllItems() {
            const list = this.getOrCreateList();
            list.innerHTML = '';
            const sortedItems = Array.from(this.feedMap.values()).sort((a, b) => new Date(b.published.full) - new Date(a.published.full));
            if (sortedItems.length === 0) {
                 if (!this.loadingBox) {
                    const box = document.createElement('div');
                    box.id = 'loadingBox';
                    box.style.padding = '28px';
                    box.style.textAlign = 'center';
                    box.style.color = 'var(--text-muted)';
                    box.innerHTML = `<div style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.04);border-top-color:var(--accent-primary);margin:0 auto 12px;animation:spin 1s linear infinite"></div>Loading RSS feed...`;
                    list.appendChild(box);
                    this.loadingBox = box;
                } else {
                    this.loadingBox.textContent = 'No posts found for this channel.';
                }
            } else {
                if (this.loadingBox) { this.loadingBox.remove(); this.loadingBox = null; }
                for (const item of sortedItems) {
                    const node = this.createNodeFromHtml(this.makeItemHtml(item));
                    this.attachHandlers(node);
                    list.appendChild(node);
                }
            }

            this.updateTotals();
            this.applyFilter();
        }

        createNodeFromHtml(html) {
            const wrapper = document.createElement('div');
            wrapper.innerHTML = html;
            return wrapper.firstElementChild;
        }

        /* ---------- filter ---------- */
        applyFilter() {
            const active = document.querySelector('.filter-btn.active')?.dataset.filter || 'all';
            for (const node of document.querySelectorAll('.feed-item')) {
                const id = node.dataset.itemId;
                const item = this.feedMap.get(id);
                if (!item) continue;
                let show = true;
                if (active === 'released') show = !item.liveStreamingDetails || (item.liveStreamingDetails && (item.liveStreamingDetails.actualEndTime || (!item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.scheduledStartTime)));
                else if (active === 'scheduled') show = item.liveStreamingDetails && item.liveStreamingDetails.scheduledStartTime && !item.liveStreamingDetails.actualStartTime;
                else if (active === 'live') show = item.liveStreamingDetails && item.liveStreamingDetails.actualStartTime && !item.liveStreamingDetails.actualEndTime;
                node.style.display = show ? '' : 'none';
            }
        }

        /* ---------- multiple channel logic ---------- */
        loadChannelFeeds() {
            this.currentChannelId = this.channelSelectEl.value;
            const currentChannel = this.channels.find(c => c.id === this.currentChannelId);
            if (!currentChannel) {
                console.error("Default channel not found.");
                return;
            }
            this.logMessage(`Switching to channel: ${currentChannel.name}`);
            this.feedMap.clear();
            
            const existingData = this.allChannelData.get(this.currentChannelId);
            if (existingData) {
                this.feedMap = existingData;
                this.renderAllItems();
            } else {
                this.feedMap.clear();
                this.renderAllItems();
                const list = this.getOrCreateList();
                 if (!this.loadingBox) {
                    const box = document.createElement('div');
                    box.id = 'loadingBox';
                    box.style.padding = '28px';
                    box.style.textAlign = 'center';
                    box.style.color = 'var(--text-muted)';
                    box.innerHTML = `<div style="width:56px;height:56px;border-radius:50%;border:6px solid rgba(255,255,255,0.04);border-top-color:var(--accent-primary);margin:0 auto 12px;animation:spin 1s linear infinite"></div>Loading RSS feed...`;
                    list.appendChild(box);
                    this.loadingBox = box;
                }
            }
        }

        async switchChannel(channelId) {
            this.currentChannelId = channelId;
            this.loadChannelFeeds();
            this.setStatus('Fetching...', 'loading');
            await this.fetchFeeds();
        }
    }

    /* ===========================
       Boot the RSSFeedReader with logic glue
       =========================== */
    (function boot() {
        const channels = [
            { id: 'UCbg8V1kty3s1kcCch2VHwEw', name: 'Kreupasanam', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCbg8V1kty3s1kcCch2VHwEw' },
            { id: 'UC8ebJ_anG4byfhC_2hT7eKw', name: 'Gregorian TV', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UC8ebJ_anG4byfhC_2hT7eKw' },
            { id: 'UCZKpTXW-WDBMa66qj27CyuQ', name: 'Shahlom TV Live', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCZKpTXW-WDBMa66qj27CyuQ' },
            { id: 'UCsh010y2VMniw_d0yvcjy0g', name: 'Shahlom Television', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCsh010y2VMniw_d0yvcjy0g' },
            { id: 'UCzxfpzSF7mz8j7bNIXyZWmA', name: 'POWERVISION TV', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCzxfpzSF7mz8j7bNIXyZWmA' },
            { id: 'UCc3XALwTEXjw2e4BLxXCOvw', name: 'VachanamTV', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCc3XALwTEXjw2e4BLxXCOvw' },
            { id: 'UCU_5oIcVdb5pjLlhrWrI_Tg', name: 'Divine Mercy Daily News', feedUrl: 'https://www.youtube.com/feeds/videos.xml?channel_id=UCU_5oIcVdb5pjLlhrWrI_Tg' }
        ];

        const app = new RSSFeedReader({
            channels: channels,
            defaultChannelId: 'UCbg8V1kty3s1kcCch2VHwEw',
            YT_API_KEY: 'AIzaSyAzDe7gqM5P_cGwxreEVtzAbrk-5BubrcM', // <--- Replace this with your key
            pollIntervalMs: 60000,
            forceStatusIntervalMs: 5 * 60 * 1000
        });

        window.app = app;

        function tickDebugTimers() {
            const now = Date.now();
            app.feedTimerEl.textContent = app.msToMMSS(Math.max(0, app.nextFeedFetchAt - now));
            app.ytTimerEl.textContent = app.msToMMSS(Math.max(0, app.nextYTApiAt - now));
        }

        setInterval(tickDebugTimers, 1000);

        window.addEventListener('error', (e) => {
            app.logMessage('Global error: ' + (e && e.message ? e.message : e));
        });

        document.addEventListener('DOMContentLoaded', () => {
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    switch (e.key) {
                        case 'r':
                            e.preventDefault();
                            app.fetchFeeds();
                            app.showMessage('Manual refresh triggered!');
                            break;
                        case ',':
                            e.preventDefault();
                            app.openModal();
                            break;
                    }
                }
                if (e.key === 'Escape' && document.getElementById('modal').style.display === 'flex') {
                    app.closeModal();
                }
            });

            document.documentElement.style.scrollBehavior = 'smooth';

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                });
            }, {threshold: 0.1});

            const observeNewItems = () => {
                document.querySelectorAll('.feed-item:not(.observed)').forEach(item => {
                    item.style.opacity = '0';
                    item.style.transform = 'translateY(20px)';
                    item.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                    item.classList.add('observed');
                    observer.observe(item);
                });
            };

            setTimeout(observeNewItems, 100);

            const feedList = document.getElementById('feedList');
            if (feedList) {
                const feedObserver = new MutationObserver(observeNewItems);
                feedObserver.observe(feedList, {childList: true});
            }
        });

        const style = document.createElement('style');
        style.textContent = `
    .feed-item.observed {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s ease, transform 0.6s ease;
    }
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: var(--card-bg);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(var(--accent-primary), var(--accent-secondary));
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(var(--accent-secondary), var(--accent-tertiary));
    }
    ::selection {
      background: var(--accent-primary);
      color: var(--bg-primary);
    }
    button:focus, input:focus {
      outline: 2px solid var(--accent-primary);
      outline-offset: 2px;
    }
    .status-item[title]:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-primary);
      color: var(--text-primary);
      padding: 0.5rem;
      border-radius: 0.5rem;
      font-size: 0.75rem;
      white-space: nowrap;
      z-index: 1000;
      border: 1px solid var(--border-subtle);
    }
  `;
        document.head.appendChild(style);

        document.getElementById('openSettings').setAttribute('title', 'Ctrl/Cmd + , to open');
    })();
</script>
</body>
</html>
